<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Untitled Design</title>
  <meta name="sim-name" content="Untitled Design">
  <meta name="engine-version" content="unversioned">
  <style>
* {
  box-sizing: border-box;
}

body {
  margin: 0;
}

:root {
  --gjs-t-color-primary: #cf549e;
  --gjs-t-color-secondary: #b9227d;
  --gjs-t-color-accent: #ffb347;
  --gjs-t-color-success: #28a745;
  --gjs-t-color-warning: #ffc107;
  --gjs-t-color-error: #dc3545;
  --bg: #0b1020;
  --card: #121a33;
  --ink: #e9f0ff;
  --muted: #9bb0ff;
  --accent: #7cc8ff;
  --ok: #3ddc97;
  --danger: #ff6b6b;
}

.gjs-t-body {
  background-color: inherit;
  color: inherit;
  font-size: 1rem;
  line-height: 1.75rem;
  font-family: Arial, Helvetica, sans-serif;
}

.gjs-t-h1 {
  color: var(--gjs-t-color-secondary);
  font-size: 1.5rem;
  line-height: 2.5rem;
}

.gjs-t-h2 {
  color: #601843;
  font-size: 1.2rem;
  line-height: 1.75rem;
}

.gjs-t-button {
  background-color: var(--gjs-t-color-primary);
  color: white;
  border-radius: 0.3rem;
}

.gjs-t-link {
  color: var(--gjs-t-color-primary);
  text-decoration: underline;
}

.gjs-t-border {
  border-radius: 0.3rem;
  border-color: #e0e0e0;
}

html,
body {
  height: 100%;
}

body {
  margin: 0;
  font: 500 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif;
  color: var(--ink);
  background: radial-gradient(1200px 800px at 80% -10%, #1b2752 0%, var(--bg) 60%);
  display: grid;
  place-items: center;
  padding: 18px;
}

.app {
  width: min(1100px, 95vw);
}

.grid {
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 18px;
}

.card {
  background: var(--card);
  border: 1px solid #1f2a50;
  border-radius: 16px;
  padding: 16px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
}

h1 {
  font-size: 20px;
  margin: 0 0 8px;
}

.sub {
  color: var(--muted);
  font-size: 13px;
}

button,
input[type=range] {
  accent-color: var(--accent);
}

.controls {
  display: grid;
  gap: 14px;
}

.row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}

.row .grow {
  flex: 1;
}

.btn {
  background: #172144;
  color: var(--ink);
  border: 1px solid #28366d;
  padding: 10px 14px;
  border-radius: 12px;
  cursor: pointer;
}

.btn:active {
  transform: translateY(1px);
}

.btn.toggle[aria-pressed="true"] {
  background: #0e2e1f;
  border-color: #1d6f4b;
  color: #d6ffee;
}

.kv {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 6px 10px;
  font-variant-numeric: tabular-nums;
}

.kv div:nth-child(odd) {
  color: var(--muted);
}

.small {
  font-size: 12px;
  color: var(--muted);
}

.stage {
  display: flex;
  align-items: center;
  justify-content: center;
}

svg {
  width: 100%;
  height: auto;
  display: block;
}

/* ============================================================================
   FLOW ANIMATIONS
   ============================================================================ */

.flow {
  stroke-dasharray: 10 12;
}

.flow.on {
  animation: dash var(--duration, 600ms) linear infinite;
}

@keyframes dash {
  to {
    stroke-dashoffset: -22;
  }
}

/* ============================================================================
   CONTROLS DRAWER
   ============================================================================ */

.controls-toggle {
  position: fixed;
  top: 12px;
  right: 12px;
  z-index: 1000;
  background: #172144;
  color: #e9f0ff;
  border: 1px solid #28366d;
  padding: 10px 14px;
  border-radius: 12px;
  cursor: pointer;
}

.controls-toggle:active {
  transform: translateY(1px);
}

.controls-drawer {
  position: fixed;
  inset: 0;
  z-index: 999;
  pointer-events: none;
}

.controls-drawer::before {
  content: "";
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.35);
  opacity: 0;
  transition: opacity 0.2s ease;
}

.controls-panel {
  position: absolute;
  top: 0;
  right: 0;
  height: 100vh;
  width: min(420px, 92vw);
  background: var(--card, #121a33);
  border-left: 1px solid #1f2a50;
  box-shadow: -20px 0 50px rgba(0, 0, 0, 0.4);
  transform: translateX(100%);
  transition: transform 0.25s ease;
  overflow: auto;
  padding: 16px;
  color: var(--ink, #e9f0ff);
}

.controls-close {
  position: sticky;
  top: 0;
  float: right;
  margin: -6px -6px 8px 8px;
  background: transparent;
  color: var(--ink, #e9f0ff);
  border: 1px solid #28366d;
  border-radius: 10px;
  padding: 6px 10px;
  cursor: pointer;
  font-size: 20px;
}

.controls-drawer.open {
  pointer-events: auto;
}

.controls-drawer.open::before {
  opacity: 1;
}

.controls-drawer.open .controls-panel {
  transform: translateX(0);
}

/* ============================================================================
   PUMP AND VALVE INTERACTION
   ============================================================================ */

/* Pump Styles */
#pump {
  cursor: pointer;
  outline: none; /* Remove focus rectangle flash */
}

#pump:focus {
  outline: none; /* Remove focus rectangle */
}

#pump:focus-visible {
  outline: 2px solid rgba(31, 212, 214, 0.6); /* Keyboard navigation only */
  outline-offset: 4px;
}

#pump image {
  pointer-events: all;
  cursor: pointer;
  transition: transform 0.2s ease, filter 0.2s ease;
}

#pump:hover image {
  transform: scale(1.08);
  filter: brightness(1.2) drop-shadow(0 0 8px rgba(31, 212, 214, 0.4));
}

/* Valve Styles */
.valve {
  cursor: pointer;
  outline: none; /* Remove focus rectangle flash */
  transform: none !important;
}

.valve:focus {
  outline: none; /* Remove focus rectangle */
}

.valve:focus-visible {
  outline: 2px solid rgba(31, 212, 214, 0.6); /* Keyboard navigation only */
  outline-offset: 4px;
}

.valve:hover {
  transform: none !important;
}

.valve:active {
  transform: none !important;
}

.valve image {
  pointer-events: all;
  cursor: pointer;
  transition: transform 0.2s ease, filter 0.2s ease;
}

.valve:hover image {
  transform: scale(1.12);
  filter: brightness(1.25) drop-shadow(0 0 10px rgba(31, 212, 214, 0.5));
}

.valve text {
  pointer-events: none;
}

.valve .valve-bg {
  transition: opacity 0.2s ease, stroke-width 0.2s ease;
}

.valve:hover .valve-bg {
  opacity: 1 !important;
  stroke-width: 3;
}

.valve:active .valve-bg {
  fill: #2a3f7a !important;
}

.ctrl-section[hidden] {
  display: none;
}

/* ============================================================================
   TANK AND LEVEL
   ============================================================================ */

.levelRect {
  transition: height 120ms linear, y 120ms linear;
}

.warn {
  color: var(--danger);
}

/* ============================================================================
   MODAL STYLES
   ============================================================================ */

.valve-modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(4px);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.valve-modal-overlay.open {
  display: flex;
  opacity: 1;
}

.valve-modal-container {
  position: relative;
  width: min(600px, 90vw);
  height: min(600px, 90vh);
  background: #0b1330;
  border-radius: 16px;
  border: 2px solid #1fd4d6;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  overflow: hidden;
  transform: scale(0.9);
  transition: transform 0.3s ease;
}

.valve-modal-overlay.open .valve-modal-container {
  transform: scale(1);
}

.valve-modal-close {
  position: absolute;
  top: 12px;
  right: 12px;
  width: 40px;
  height: 40px;
  background: rgba(255, 107, 107, 0.9);
  border: 2px solid #ff8787;
  border-radius: 50%;
  color: white;
  font-size: 28px;
  line-height: 1;
  cursor: pointer;
  z-index: 10;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.valve-modal-close:hover {
  background: rgba(255, 107, 107, 1);
  transform: scale(1.1);
}

.valve-modal-title {
  padding: 16px 24px;
  background: rgba(31, 212, 214, 0.1);
  border-bottom: 1px solid #1fd4d6;
  color: #e9f0ff;
  font-size: 18px;
  font-weight: 600;
}

.valve-modal-container iframe {
  width: 100%;
  height: calc(100% - 60px);
  border: none;
  display: block;
}

/* ============================================================================
   SPECIFIC ELEMENT IDS
   ============================================================================ */

#i8u9j {
  min-width: 128px;
}

#qoutVal {
  width: 64px;
  text-align: right;
}

#id1ii {
  min-width: 128px;
}

#qinVal {
  width: 64px;
  text-align: right;
}

#iiezj {
  min-width: 128px;
}

#areaVal {
  width: 64px;
  text-align: right;
}

#irdd2 {
  margin-top: 10px;
}

#iaxfc5 {
  margin: 8px 0 0;
}

#kVal {
  width: 64px;
  text-align: right;
}

#i3zec {
  margin-top: 12px;
}

#ir0ydi {
  border-color: #22305f;
  opacity: 0.5;
  margin: 14px 0;
}

#iuele {
  margin: 0;
}

  </style>
</head>
<body>



<button id="controlsToggle" class="controls-toggle" aria-controls="controlsDrawer" aria-expanded="false">
  Controls
</button>
  
<div id="ie7wb" class="app">
  <div id="i4pt7" class="grid">
    <div id="i3bwj" class="card stage">
      <svg viewBox="0 0 1000 600" aria-labelledby="title desc" role="img" id="iuele">
        <title id="title">Tank and Pipe Visualization</title>
        <desc id="desc">Click components to interact. Watch animated flow!</desc>
        
        <defs id="ic988">
          <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
            <path d="M 40 0 L 0 0 0 40" fill="none" stroke="#22305f" stroke-width="1"></path>
          </pattern>
          <linearGradient id="liquid" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="#7cc8ff"></stop>
            <stop offset="100%" stop-color="#2d8bd6"></stop>
          </linearGradient>
        </defs>
        
        <rect x="0" y="0" width="1000" height="600" fill="url(#grid)" opacity="0.4"></rect>
        
        <!-- ========================================
             PIPES (BACKGROUND LAYER - DRAWN FIRST)
             ======================================== -->
        
        <!-- SECTION 1: SOURCE TO INLET VALVE -->
        <g id="sourceToInlet">
          <path d="M 80 70 H 220" fill="none" stroke="#9bb0ff" stroke-width="20" stroke-linecap="round"></path>
          <path id="pipe1Flow" d="M 80 70 H 220" fill="none" stroke="#7cc8ff" stroke-width="8" stroke-linecap="round" class="flow"></path>
        </g>
        
        <!-- SECTION 2: INLET VALVE TO TANK TOP -->
        <g id="inletToTank">
          <path d="M 240 70 H 380 V 125" fill="none" stroke="#9bb0ff" stroke-width="20" stroke-linecap="round"></path>
          <path id="pipe2Flow" d="M 240 70 H 380 V 125" fill="none" stroke="#7cc8ff" stroke-width="8" stroke-linecap="round" class="flow"></path>
        </g>
        
        <!-- SECTION 3: TANK BOTTOM TO PUMP INLET -->
        <g id="tankToPump">
          <path d="M 660 460 H 770" fill="none" stroke="#9bb0ff" stroke-width="20" stroke-linecap="round"></path>
          <path id="pipe3Flow" d="M 660 460 H 770" fill="none" stroke="#7cc8ff" stroke-width="8" stroke-linecap="round" class="flow"></path>
        </g>
        
        <!-- SECTION 4: PUMP OUTLET TO OUTLET VALVE -->
        <g id="pumpToOutlet">
          <path d="M 810 460 V 295 H 880" fill="none" stroke="#9bb0ff" stroke-width="20" stroke-linecap="round" stroke-linejoin="round"></path>
          <path id="pipe4Flow" d="M 810 460 V 295 H 880" fill="none" stroke="#7cc8ff" stroke-width="8" stroke-linecap="round" stroke-linejoin="round" class="flow"></path>
        </g>
        
        <!-- SECTION 5: OUTLET VALVE TO DRAIN -->
        <g id="outletToDrain">
          <path d="M 900 295 H 960" fill="none" stroke="#9bb0ff" stroke-width="20" stroke-linecap="round"></path>
          <path id="pipe5Flow" d="M 900 295 H 960" fill="none" stroke="#7cc8ff" stroke-width="8" stroke-linecap="round" class="flow"></path>
        </g>
        
        <!-- ========================================
             COMPONENTS (FOREGROUND LAYER - DRAWN ON TOP)
             ======================================== -->
        
        <!-- INLET VALVE -->
        <g id="valve" class="valve" tabindex="0" role="button" aria-pressed="false" aria-label="Open inlet valve control">
          <g transform="translate(230, 53)">
            <image href="https://sco314.github.io/tank-sim/Valve-Icon-Transparent-bg.png" x="-38" y="-38" width="76" height="76" />
          </g>
        </g>
        
        <!-- TANK -->
        <g id="tank" transform="translate(340, 120)">
          <rect x="0" y="0" width="320" height="360" rx="18" fill="#0e1734" stroke="#2a3d78" stroke-width="4"></rect>
          <rect id="levelRect" x="6" y="360" width="308" height="0" fill="url(#liquid)" class="levelRect"></rect>
          <g id="ticks" stroke="#334a90">
            <path d="M0 60 h-14 M0 120 h-14 M0 180 h-14 M0 240 h-14 M0 300 h-14"></path>
            <text x="-20" y="66" text-anchor="end" fill="#9bb0ff" font-size="12">80%</text>
            <text x="-20" y="126" text-anchor="end" fill="#9bb0ff" font-size="12">60%</text>
            <text x="-20" y="186" text-anchor="end" fill="#9bb0ff" font-size="12">40%</text>
            <text x="-20" y="246" text-anchor="end" fill="#9bb0ff" font-size="12">20%</text>
            <text x="-20" y="306" text-anchor="end" fill="#9bb0ff" font-size="12">0%</text>
          </g>
        </g>
        
        <!-- PUMP -->
        <g id="pump" class="pump" transform="translate(790,460)" tabindex="0" role="button" aria-pressed="false" aria-label="Toggle pump">
          <image href="https://sco314.github.io/tank-sim/cent-pump-9-inlet-left.png" x="-20" y="-130" width="230" height="230" />
        </g>
        
        <!-- OUTLET VALVE -->
        <g id="outletValve" class="valve" tabindex="0" role="button" aria-pressed="true" aria-label="Open outlet valve control">
          <g transform="translate(890,278)">
            <image href="https://sco314.github.io/tank-sim/Valve-Icon-Transparent-bg.png" x="-38" y="-38" width="76" height="76" />
          </g>
        </g>
      </svg>
    </div>

    <!-- Controls Drawer -->
    <aside id="controlsDrawer" class="controls-drawer" aria-hidden="true">
      <div class="controls-panel card" role="dialog" aria-modal="true" aria-labelledby="controlsTitle">
        <button id="controlsClose" class="controls-close" aria-label="Close controls">√ó</button>

        <div id="ixaoq">
          <h1 id="controlsTitle">System Controls</h1>
          <div class="sub">Phase 6 Testing: Flow animations active! Watch the animated dashes flow through pipes based on actual flow rates.</div>
          
          <div id="i3zec" class="controls">
            <div class="row">
              <button type="button" id="pauseBtn" aria-pressed="false" class="btn">Pause</button>
              <button type="button" id="resetBtn" class="btn">Reset</button>
            </div>
          </div>

          <hr/>
          <h1>Tank Status</h1>
          <div class="kv" id="tankStatus">
            <div>Level</div><div id="tank1Level">0%</div>
            <div>Volume</div><div id="tank1Volume">0.000 m¬≥</div>
            <div>Status</div><div id="tank1Status">‚ö†Ô∏è EMPTY</div>
            <div>Flow In</div><div id="tank1FlowIn">0.00 m¬≥/s</div>
            <div>Flow Out</div><div id="tank1FlowOut">0.00 m¬≥/s</div>
          </div>

          <hr/>
          <h1>Flow Status</h1>
          <div class="kv" id="flowStatus">
            <div>Inlet Pipe</div><div id="inletPipeFlow">0.00 m¬≥/s</div>
            <div>Status</div><div id="inletPipeStatus">‚≠ï No Flow</div>
            <div>Outlet Pipe</div><div id="outletPipeFlow">0.00 m¬≥/s</div>
            <div>Status</div><div id="outletPipeStatus">‚≠ï No Flow</div>
          </div>

          <hr/>
          <h1>Pressure Sensors</h1>
          <div class="kv" id="pressureStatus">
            <div>Tank Bottom</div><div id="p1Pressure">0.00 bar</div>
            <div>Status</div><div id="p1Status">‚úÖ OK</div>
            <div>Pump Inlet</div><div id="p2Pressure">0.00 bar</div>
            <div>Status</div><div id="p2Status">‚úÖ OK</div>
            <div>Pump Outlet</div><div id="p3Pressure">0.00 bar</div>
            <div>Status</div><div id="p3Status">‚úÖ OK</div>
            <div>System Outlet</div><div id="p4Pressure">0.00 bar</div>
            <div>Status</div><div id="p4Status">‚úÖ OK</div>
          </div>

          <hr/>
          <h1>Component Status</h1>
          <div class="kv" id="systemStatus">
            <div>Pump</div><div id="pumpStatus">Loading...</div>
            <div>Pump Flow</div><div id="pumpFlow">0.00 m¬≥/s</div>
            <div>Inlet Valve</div><div id="inletValveStatus">Loading...</div>
            <div>Outlet Valve</div><div id="outletValveStatus">Loading...</div>
          </div>
          
          <hr/>
          <h1>Debug</h1>
          <button type="button" id="debugBtn" class="btn">Show Debug Info</button>
          <pre id="debugOutput" style="display:none; font-size:10px; max-height:200px; overflow:auto; background:#0e1734; padding:8px; margin-top:8px;"></pre>
        </div>
      </div>
    </aside>
  </div>
</div>

<!-- Controls Drawer Script -->
<script>
(function(){
  const drawer   = document.getElementById('controlsDrawer');
  const panel    = drawer.querySelector('.controls-panel');
  const toggle   = document.getElementById('controlsToggle');
  const closeBtn = document.getElementById('controlsClose');

  function openDrawer(){
    drawer.classList.add('open');
    drawer.setAttribute('aria-hidden','false');
    toggle.setAttribute('aria-expanded','true');
    setTimeout(() => closeBtn.focus(), 0);
  }
  function closeDrawer(){
    drawer.classList.remove('open');
    drawer.setAttribute('aria-hidden','true');
    toggle.setAttribute('aria-expanded','false');
    toggle.focus();
  }

  toggle.addEventListener('click', openDrawer);
  closeBtn.addEventListener('click', closeDrawer);
  drawer.addEventListener('click', (e) => {
    if (!panel.contains(e.target)) closeDrawer();
  });
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && drawer.classList.contains('open')) closeDrawer();
  });
  
  // Pause button
  const pauseBtn = document.getElementById('pauseBtn');
  pauseBtn?.addEventListener('click', () => {
    if (window.componentManager) {
      if (window.componentManager.paused) {
        window.componentManager.resume();
        pauseBtn.textContent = 'Pause';
      } else {
        window.componentManager.pause();
        pauseBtn.textContent = 'Resume';
      }
    }
  });
  
  // Reset button
  const resetBtn = document.getElementById('resetBtn');
  resetBtn?.addEventListener('click', () => {
    if (window.componentManager) {
      window.componentManager.reset();
      console.log('System reset');
    }
  });
  
  // Debug button
  const debugBtn = document.getElementById('debugBtn');
  const debugOutput = document.getElementById('debugOutput');
  debugBtn?.addEventListener('click', () => {
    if (window.componentManager) {
      const info = window.componentManager.getSystemInfo();
      debugOutput.textContent = JSON.stringify(info, null, 2);
      debugOutput.style.display = debugOutput.style.display === 'none' ? 'block' : 'none';
    }
  });
  
  // Update status every second
  setInterval(() => {
    if (window.componentManager) {
      // Update pump status
      if (window.componentManager.pumpManager) {
        const pump = window.componentManager.pumpManager.getPump('mainPump');
        if (pump) {
          document.getElementById('pumpStatus').textContent = pump.running ? '‚úÖ RUNNING' : '‚≠ï OFF';
          document.getElementById('pumpStatus').style.color = pump.running ? '#3ddc97' : '#9bb0ff';
          document.getElementById('pumpFlow').textContent = pump.getOutputFlow().toFixed(2) + ' m¬≥/s';
        }
      }
      
      // Update valve status
      if (window.componentManager.valveManager) {
        const inletValve = window.componentManager.valveManager.getValve('inlet');
        const outletValve = window.componentManager.valveManager.getValve('outlet');
        
        if (inletValve) {
          const pct = inletValve.getPositionPercent();
          document.getElementById('inletValveStatus').textContent = pct + '% open';
          document.getElementById('inletValveStatus').style.color = pct > 0 ? '#3ddc97' : '#9bb0ff';
        }
        
        if (outletValve) {
          const pct = outletValve.getPositionPercent();
          document.getElementById('outletValveStatus').textContent = pct + '% open';
          document.getElementById('outletValveStatus').style.color = pct > 0 ? '#3ddc97' : '#9bb0ff';
        }
      }
      
      // Update pipe flow status
      if (window.componentManager.pipeManager) {
        const pipe2 = window.componentManager.pipeManager.getPipe('inletToTank');
        const pipe4 = window.componentManager.pipeManager.getPipe('pumpToOutlet');
        
        if (pipe2) {
          const flow = pipe2.flowRate;
          document.getElementById('inletPipeFlow').textContent = flow.toFixed(2) + ' m¬≥/s';
          
          const statusEl = document.getElementById('inletPipeStatus');
          if (flow > 0.001) {
            statusEl.textContent = 'üíß Flowing';
            statusEl.style.color = '#3ddc97';
          } else {
            statusEl.textContent = '‚≠ï No Flow';
            statusEl.style.color = '#9bb0ff';
          }
        }
        
        if (pipe4) {
          const flow = pipe4.flowRate;
          document.getElementById('outletPipeFlow').textContent = flow.toFixed(2) + ' m¬≥/s';
          
          const statusEl = document.getElementById('outletPipeStatus');
          if (flow > 0.001) {
            statusEl.textContent = 'üíß Flowing';
            statusEl.style.color = '#3ddc97';
          } else {
            statusEl.textContent = '‚≠ï No Flow';
            statusEl.style.color = '#9bb0ff';
          }
        }
      }
    }
  }, 1000);
})();
</script>



<!-- System Configuration (for re-import) -->
<script id="system-config" type="application/json">
{
  "metadata": {
    "version": "2.0.1",
    "created": "2025-10-17T11:23:27.051Z",
    "modified": "2025-10-17T11:23:27.051Z",
    "name": "Untitled Design",
    "exported": "2025-10-17T11:25:48.499Z"
  },
  "components": [
    {
      "id": "comp_1",
      "key": "feed",
      "type": "feed",
      "name": "Feed 2",
      "x": 180,
      "y": 180,
      "config": {
        "type": "feed",
        "supplyPressure": 3,
        "maxFlow": null,
        "temperature": 20,
        "inputs": [],
        "outputs": [
          "comp_2"
        ]
      }
    },
    {
      "id": "comp_2",
      "key": "valve",
      "type": "valve",
      "name": "Valve 3",
      "x": 300,
      "y": 180,
      "config": {
        "type": "valve",
        "open": 75,
        "kv": 1,
        "inputs": [
          "comp_1"
        ],
        "outputs": [
          "comp_3"
        ]
      }
    },
    {
      "id": "comp_3",
      "key": "tank",
      "type": "tank",
      "name": "Tank 4",
      "x": 460,
      "y": 220,
      "config": {
        "type": "tank",
        "capacity": 10,
        "initialLevel": 2,
        "maxLevel": 9.5,
        "inputs": [
          "comp_2"
        ],
        "outputs": [
          "comp_4"
        ]
      }
    },
    {
      "id": "comp_4",
      "key": "valve",
      "type": "valve",
      "name": "Valve 5",
      "x": 600,
      "y": 240,
      "config": {
        "type": "valve",
        "open": 55,
        "kv": 1,
        "inputs": [
          "comp_3"
        ],
        "outputs": [
          "comp_5"
        ]
      }
    },
    {
      "id": "comp_5",
      "key": "fixedPump",
      "type": "pumpFixed",
      "name": "Fixed Speed Pump 6",
      "x": 720,
      "y": 240,
      "config": {
        "type": "pumpFixed",
        "head": 10,
        "efficiency": 0.7,
        "maxFlow": 1,
        "inputs": [
          "comp_4"
        ],
        "outputs": [
          "comp_6"
        ]
      }
    },
    {
      "id": "comp_6",
      "key": "drain",
      "type": "drain",
      "name": "Drain 7",
      "x": 840,
      "y": 240,
      "config": {
        "type": "drain",
        "ambientPressure": 1,
        "maxCapacity": null,
        "inputs": [
          "comp_5"
        ],
        "outputs": []
      }
    }
  ],
  "connections": [
    {
      "id": "conn_1",
      "from": "comp_1",
      "to": "comp_2",
      "fromPoint": "outlet",
      "toPoint": "inlet"
    },
    {
      "id": "conn_2",
      "from": "comp_2",
      "to": "comp_3",
      "fromPoint": "outlet",
      "toPoint": "left"
    },
    {
      "id": "conn_3",
      "from": "comp_3",
      "to": "comp_4",
      "fromPoint": "right",
      "toPoint": "inlet"
    },
    {
      "id": "conn_4",
      "from": "comp_4",
      "to": "comp_5",
      "fromPoint": "outlet",
      "toPoint": "inlet"
    },
    {
      "id": "conn_5",
      "from": "comp_5",
      "to": "comp_6",
      "fromPoint": "outlet",
      "toPoint": "inlet"
    }
  ],
  "nextId": 7,
  "nextConnectionId": 6,
  "gridSize": 20,
  "viewBox": {
    "width": 1000,
    "height": 600
  }
}
</script>

<!-- Simulator Engine -->
<script>
/**
 * Component.js - Base class for all system components
 * 
 * All components (tanks, pumps, valves, pipes, feeds, drains) inherit from this.
 * Supports boundary components with no inputs (feeds) or no outputs (drains).
 */

class Component {
  constructor(config) {
    this.id = config.id;
    this.type = config.type; // 'tank', 'pump', 'valve', 'pipe', 'sensor', 'feed', 'drain'
    this.name = config.name || this.id;
    
    // CRITICAL: Store flowNetwork reference
    this.flowNetwork = config.flowNetwork || null;
    
    // Flow connections
    this.inputs = config.inputs || [];
    this.outputs = config.outputs || [];
    
    // Visual
    this.svgElement = config.svgElement || null;
    this.position = config.position || [0, 0]; // [x, y]
    
    // State
    this.enabled = config.enabled !== false; // Default enabled
    this.state = {}; // Component-specific state
    
    // Callbacks
    this.onChange = null; // Called when component changes
    
    // Validate configuration
    this._validateConfiguration();
    
    console.log(`Component created: ${this.type} - ${this.id}`);
  }

  /**
   * Validate component configuration
   * Relaxed for boundary components (feeds can have no inputs, drains can have no outputs)
   */
  _validateConfiguration() {
    // Check for required fields
    if (!this.id) {
      console.error('Component must have an ID');
      return;
    }
    
    if (!this.type) {
      console.error(`Component ${this.id} must have a type`);
      return;
    }
    
    // Boundary components have relaxed validation
    if (this.isBoundary()) {
      if (this.type === 'feed' || this.type === 'source') {
        // Feeds/sources should have NO inputs, but must have outputs
        if (this.inputs.length > 0) {
          console.warn(`${this.type} ${this.id} should not have inputs (boundary condition)`);
        }
        if (this.outputs.length === 0) {
          console.warn(`${this.type} ${this.id} has no outputs - will not supply flow to anything`);
        }
      } else if (this.type === 'drain' || this.type === 'sink') {
        // Drains/sinks should have NO outputs, but must have inputs
        if (this.outputs.length > 0) {
          console.warn(`${this.type} ${this.id} should not have outputs (boundary condition)`);
        }
        if (this.inputs.length === 0) {
          console.warn(`${this.type} ${this.id} has no inputs - will not receive flow from anything`);
        }
      }
    } else {
      // Non-boundary components should generally have both inputs and outputs
      // (though some exceptions like sensors might only have inputs)
      if (this.inputs.length === 0 && this.type !== 'sensor') {
        console.warn(`${this.type} ${this.id} has no inputs - may not receive flow`);
      }
      if (this.outputs.length === 0 && this.type !== 'sensor') {
        console.warn(`${this.type} ${this.id} has no outputs - may not supply flow`);
      }
    }
  }

  /**
   * Check if this component is a boundary node (source or sink)
   * Override in subclasses or check type
   */
  isBoundary() {
    return this.type === 'feed' || 
           this.type === 'source' || 
           this.type === 'drain' || 
           this.type === 'sink';
  }

  /**
   * Get DOM element
   */
  getElement() {
    if (!this.svgElement) return null;
    if (typeof this.svgElement === 'string') {
      return document.querySelector(this.svgElement);
    }
    return this.svgElement;
  }

  /**
   * Enable/disable component
   */
  setEnabled(enabled) {
    this.enabled = !!enabled;
    this.notifyChange();
  }

  isEnabled() {
    return this.enabled;
  }

  /**
   * Notify system of changes
   */
  notifyChange() {
    if (this.onChange) {
      this.onChange(this);
    }
  }

  /**
   * Get input flow (override in subclasses)
   */
  getInputFlow() {
    return 0;
  }

  /**
   * Get output flow (override in subclasses)
   */
  getOutputFlow() {
    return 0;
  }

  /**
   * Update component state (override in subclasses)
   */
  update(dt) {
    // Override in subclasses
  }

  /**
   * Render visual representation (override in subclasses)
   */
  render() {
    // Override in subclasses
  }

  /**
   * Get component info for debugging
   */
  getInfo() {
    return {
      id: this.id,
      type: this.type,
      name: this.name,
      enabled: this.enabled,
      isBoundary: this.isBoundary(),
      inputs: this.inputs,
      outputs: this.outputs,
      state: this.state
    };
  }

  /**
   * Reset component to initial state (override in subclasses)
   */
  reset() {
    this.enabled = true;
    this.state = {};
  }

  /**
   * Destroy component (cleanup)
   */
  destroy() {
    this.onChange = null;
    this.svgElement = null;
    this.flowNetwork = null;
  }
}

// Export
window.Component = Component;


/**
 * FlowNetwork.js - Manages flow calculations between components
 * 
 * Component-only topology: no pipes in flow routing
 * Supports boundary conditions (feeds and drains)
 */

class FlowNetwork {
  constructor() {
    this.components = new Map(); // Map<id, Component>
    this.flows = new Map(); // Map<'from->to', flowRate>
    this.pressures = new Map(); // Map<id, pressure> (optional)
  }

  /**
   * Register a component in the network
   */
  addComponent(component) {
    if (!component.id) {
      console.error('Component must have an ID');
      return;
    }
    
    // Store reference to this network in the component
    component.flowNetwork = this;
    
    this.components.set(component.id, component);
    console.log(`Added ${component.type} to flow network: ${component.id}`);
  }

  /**
   * Remove a component from the network
   */
  removeComponent(componentId) {
    const component = this.components.get(componentId);
    if (component) {
      component.flowNetwork = null;
    }
    
    this.components.delete(componentId);
    
    // Clear flows involving this component
    for (const [key, value] of this.flows.entries()) {
      if (key.includes(componentId)) {
        this.flows.delete(key);
      }
    }
  }

  /**
   * Get a component by ID
   */
  getComponent(id) {
    return this.components.get(id);
  }

  /**
   * Get all components of a specific type
   */
  getComponentsByType(type) {
    const result = [];
    for (const component of this.components.values()) {
      if (component.type === type) {
        result.push(component);
      }
    }
    return result;
  }

  /**
   * Set flow rate between two components
   */
  setFlow(fromId, toId, flowRate) {
    const key = `${fromId}->${toId}`;
    this.flows.set(key, flowRate);
  }

  /**
   * Get flow rate between two components
   */
  getFlow(fromId, toId) {
    const key = `${fromId}->${toId}`;
    return this.flows.get(key) || 0;
  }

  /**
   * Get total input flow to a component
   */
  getInputFlow(componentId) {
    let total = 0;
    for (const [key, flow] of this.flows.entries()) {
      if (key.endsWith(`->${componentId}`)) {
        total += flow;
      }
    }
    return total;
  }

  /**
   * Get total output flow from a component
   */
  getOutputFlow(componentId) {
    let total = 0;
    for (const [key, flow] of this.flows.entries()) {
      if (key.startsWith(`${componentId}->`)) {
        total += flow;
      }
    }
    return total;
  }

  /**
   * Calculate all flows in the network
   * Component-only topology with boundary handling
   */
  calculateFlows(dt) {
    // Clear existing flows
    this.flows.clear();

    // CRITICAL: Processing order for component-only topology
    // - 'feed': Boundary sources (infinite supply)
    // - 'valve': Flow controllers
    // - 'pump': Active movers (creates tank->pump flow)
    // - 'drain': Boundary sinks (infinite capacity)
    // - 'sensor': Monitors only
    // 
    // NOTE: 'tank' is NOT in the list - tanks are passive
    // NOTE: 'pipe' is NOT in the list - pipes are visual only
    const order = ['feed', 'valve', 'pump', 'drain', 'sensor'];
    
    for (const type of order) {
      const components = this.getComponentsByType(type);
      
      for (const component of components) {
        if (!component.enabled) continue;
        
        // Calculate output flow for this component
        const outputFlow = component.getOutputFlow();
        
        // Distribute flow to all outputs
        if (component.outputs && component.outputs.length > 0) {
          const flowPerOutput = outputFlow / component.outputs.length;
          
          for (const outputId of component.outputs) {
            this.setFlow(component.id, outputId, flowPerOutput);
          }
        }
      }
    }
    
    // BOUNDARY HANDLING: Ensure boundary conditions are satisfied
    this._applyBoundaryConditions();
  }

  /**
   * Apply boundary conditions (feeds and drains)
   */
  _applyBoundaryConditions() {
    // Feeds inject flow at their outputs
    const feeds = this.getComponentsByType('feed');
    for (const feed of feeds) {
      if (!feed.enabled) continue;
      
      // Feed provides flow based on downstream demand
      // This is already handled in calculateFlows, but we could
      // add pressure-based calculations here in the future
    }
    
    // Drains accept all incoming flow
    const drains = this.getComponentsByType('drain');
    for (const drain of drains) {
      if (!drain.enabled) continue;
      
      // Drain accepts whatever flows into it
      // No action needed - just verify flow is recorded
      const inflow = this.getInputFlow(drain.id);
      if (inflow > 0) {
        // Flow successfully reaches drain
      }
    }
  }

  /**
   * Update all components in the network
   */
  updateComponents(dt) {
    for (const component of this.components.values()) {
      if (component.enabled) {
        component.update(dt);
      }
    }
  }

  /**
   * Render all components
   */
  renderComponents() {
    for (const component of this.components.values()) {
      component.render();
    }
  }

  /**
   * Build network from config and validate
   * Component-only topology with clear error messages
   */
  buildFromConfig(config) {
    console.log('Building flow network from config...');
    
    // Components are added by their respective managers
    // This method validates connections
    
    let validConnections = 0;
    let invalidConnections = 0;
    const errors = [];
    
    for (const component of this.components.values()) {
      // Check if all inputs exist and are valid
      for (const inputId of component.inputs) {
        const inputComponent = this.components.get(inputId);
        
        if (inputComponent) {
          validConnections++;
        } else {
          // CLEAR ERROR MESSAGE
          const errorMsg = `Component "${component.id}" (${component.type}) has invalid input: "${inputId}" - component does not exist`;
          errors.push(errorMsg);
          console.error(`‚ùå ${errorMsg}`);
          invalidConnections++;
        }
      }
      
      // Check if all outputs exist and are valid
      for (const outputId of component.outputs) {
        const outputComponent = this.components.get(outputId);
        
        if (outputComponent) {
          validConnections++;
        } else {
          // CLEAR ERROR MESSAGE
          const errorMsg = `Component "${component.id}" (${component.type}) has invalid output: "${outputId}" - component does not exist`;
          errors.push(errorMsg);
          console.error(`‚ùå ${errorMsg}`);
          invalidConnections++;
        }
      }
      
      // Validate boundary components
      if (component.isBoundary && component.isBoundary()) {
        if (component.type === 'feed' && component.inputs.length > 0) {
          console.warn(`‚ö†Ô∏è Feed "${component.id}" has inputs - feeds should have no inputs (boundary condition)`);
        }
        if (component.type === 'drain' && component.outputs.length > 0) {
          console.warn(`‚ö†Ô∏è Drain "${component.id}" has outputs - drains should have no outputs (boundary condition)`);
        }
      }
    }
    
    // Report results
    const summary = `Network built: ${this.components.size} components, ${validConnections} valid connections, ${invalidConnections} invalid`;
    
    if (invalidConnections > 0) {
      console.error(`‚ùå ${summary}`);
      console.error('‚ùå Invalid connections found:', errors);
    } else {
      console.log(`‚úÖ ${summary}`);
    }
    
    // Log topology for debugging
    if (invalidConnections === 0) {
      this._logTopology();
    }
  }

  /**
   * Log network topology for debugging
   */
  _logTopology() {
    console.log('üìä Network Topology:');
    
    // Find the flow path from feed to drain
    const feeds = this.getComponentsByType('feed');
    const drains = this.getComponentsByType('drain');
    
    if (feeds.length > 0 && drains.length > 0) {
      const path = this._findPath(feeds[0].id, drains[0].id);
      if (path) {
        console.log('Flow path:', path.join(' ‚Üí '));
      }
    }
    
    // List all components by type
    const types = ['feed', 'valve', 'tank', 'pump', 'drain', 'sensor', 'pipe'];
    for (const type of types) {
      const components = this.getComponentsByType(type);
      if (components.length > 0) {
        console.log(`  ${type}s (${components.length}):`, components.map(c => c.id).join(', '));
      }
    }
  }

  /**
   * Find path between two components (for debugging)
   */
  _findPath(startId, endId, visited = new Set()) {
    if (startId === endId) return [endId];
    if (visited.has(startId)) return null;
    
    visited.add(startId);
    const component = this.getComponent(startId);
    if (!component) return null;
    
    for (const outputId of component.outputs) {
      const path = this._findPath(outputId, endId, visited);
      if (path) {
        return [startId, ...path];
      }
    }
    
    return null;
  }

  /**
   * Get network info for debugging
   */
  getNetworkInfo() {
    const info = {
      componentCount: this.components.size,
      components: [],
      flows: [],
      boundaries: {
        feeds: [],
        drains: []
      }
    };
    
    for (const component of this.components.values()) {
      const componentInfo = component.getInfo();
      info.components.push(componentInfo);
      
      // Track boundary components
      if (component.type === 'feed') {
        info.boundaries.feeds.push(component.id);
      } else if (component.type === 'drain') {
        info.boundaries.drains.push(component.id);
      }
    }
    
    for (const [key, flow] of this.flows.entries()) {
      info.flows.push({ connection: key, flow });
    }
    
    return info;
  }

  /**
   * Verify network integrity (diagnostic tool)
   */
  verifyIntegrity() {
    console.log('üîç Verifying network integrity...');
    
    const issues = [];
    
    // Check for orphaned components
    for (const component of this.components.values()) {
      if (component.type === 'feed' || component.type === 'drain') continue;
      
      if (component.inputs.length === 0 && component.outputs.length === 0) {
        issues.push(`Component "${component.id}" is orphaned (no connections)`);
      }
    }
    
    // Check for flow continuity
    const feeds = this.getComponentsByType('feed');
    const drains = this.getComponentsByType('drain');
    
    if (feeds.length === 0) {
      issues.push('No feed (source) components found - system has no inlet');
    }
    
    if (drains.length === 0) {
      issues.push('No drain (sink) components found - system has no outlet');
    }
    
    // Check for path from feed to drain
    if (feeds.length > 0 && drains.length > 0) {
      const path = this._findPath(feeds[0].id, drains[0].id);
      if (!path) {
        issues.push('No valid flow path from feed to drain');
      }
    }
    
    if (issues.length > 0) {
      console.warn('‚ö†Ô∏è Network integrity issues:', issues);
      return false;
    } else {
      console.log('‚úÖ Network integrity verified');
      return true;
    }
  }

  /**
   * Reset entire network
   */
  reset() {
    this.flows.clear();
    this.pressures.clear();
    
    for (const component of this.components.values()) {
      component.reset();
    }
    
    console.log('Flow network reset');
  }

  /**
   * Clear network
   */
  clear() {
    for (const component of this.components.values()) {
      component.destroy();
    }
    
    this.components.clear();
    this.flows.clear();
    this.pressures.clear();
    
    console.log('Flow network cleared');
  }
}

// Export
window.FlowNetwork = FlowNetwork;


/**
 * ComponentManager.js - Master orchestrator with boundary component support
 */

class ComponentManager {
  constructor(config) {
    this.config = config;
    this.flowNetwork = new FlowNetwork();
    
    // Component managers
    this.valveManager = null;
    this.pumpManager = null;
    this.tankManager = null;
    this.pipeManager = null;
    this.pressureManager = null;
    
    // Boundary components (no managers needed - simple instantiation)
    this.feeds = {};
    this.drains = {};
    
    // Simulation state
    this.running = false;
    this.paused = false;
    this.lastTime = performance.now();
    
    console.log('ComponentManager initialized');
  }

  /**
   * Initialize all component managers
   */
  async initialize() {
    console.log('Initializing component managers...');
    
    try {
      // CRITICAL: Initialize in correct order
      // 1. Boundary conditions first
      await this._initializeBoundaries();
      
      // 2. Physical components
      await this._initializeTanks();
      await this._initializePumps();
      await this._initializeValves();
      
      // 3. Sensors and visual elements
      await this._initializePressureSensors();
      await this._initializePipes();
      
      // Build and validate flow network
      this.flowNetwork.buildFromConfig(this.config);
      this.flowNetwork.verifyIntegrity();
      
      console.log('All component managers initialized successfully');
      return true;
    } catch (error) {
      console.error('Failed to initialize component managers:', error);
      return false;
    }
  }

  /**
   * Initialize boundary conditions (feeds and drains)
   */
  async _initializeBoundaries() {
    // Initialize feeds
    if (this.config.feeds && window.Feed) {
      for (const [key, cfg] of Object.entries(this.config.feeds)) {
        const feed = new Feed(cfg);
        this.feeds[key] = feed;
        this.flowNetwork.addComponent(feed);
        console.log(`‚úì Feed created: ${feed.id}`);
      }
    }
    
    // Initialize drains
    if (this.config.drains && window.Drain) {
      for (const [key, cfg] of Object.entries(this.config.drains)) {
        const drain = new Drain(cfg);
        this.drains[key] = drain;
        this.flowNetwork.addComponent(drain);
        console.log(`‚úì Drain created: ${drain.id}`);
      }
    }
    
    console.log('‚úì Boundary components ready');
  }

  /**
   * Initialize tank manager
   */
  async _initializeTanks() {
    if (!this.config.tanks || !window.TankManager) return;
    
    this.tankManager = new TankManager(this.config.tanks, this.flowNetwork);
    console.log('‚úì TankManager ready');
  }

  /**
   * Initialize pump manager
   */
  async _initializePumps() {
    if (!this.config.pumps || !window.PumpManager) return;
    
    this.pumpManager = new PumpManager(this.config.pumps, this.flowNetwork);
    console.log('‚úì PumpManager ready');
  }

  /**
   * Initialize valve manager
   */
  async _initializeValves() {
    if (!this.config.valves || !window.ValveManager) return;
    
    this.valveManager = new ValveManager(this.config.valves, this.flowNetwork);
    console.log('‚úì ValveManager ready');
  }

  /**
   * Initialize pipe manager (VISUAL ONLY)
   */
  async _initializePipes() {
    if (!this.config.pipes || !window.PipeManager) return;
    
    this.pipeManager = new PipeManager(this.config.pipes, this.flowNetwork);
    console.log('‚úì PipeManager ready (visual only)');
  }

  /**
   * Initialize pressure sensor manager
   */
  async _initializePressureSensors() {
    if (!this.config.pressureSensors || !window.PressureManager) return;
    
    this.pressureManager = new PressureManager(this.config.pressureSensors, this.flowNetwork);
    console.log('‚úì PressureManager ready');
  }

  /**
   * Start simulation
   */
  start() {
    if (this.running) return;
    
    this.running = true;
    this.paused = false;
    this.lastTime = performance.now();
    
    this._simulationLoop();
    console.log('Simulation started');
  }

  /**
   * Pause simulation
   */
  pause() {
    this.paused = true;
    console.log('Simulation paused');
  }

  /**
   * Resume simulation
   */
  resume() {
    if (!this.running) {
      this.start();
      return;
    }
    
    this.paused = false;
    this.lastTime = performance.now();
    console.log('Simulation resumed');
  }

  /**
   * Stop simulation
   */
  stop() {
    this.running = false;
    this.paused = false;
    console.log('Simulation stopped');
  }

  /**
   * Main simulation loop
   */
  _simulationLoop() {
    if (!this.running) return;
    
    const now = performance.now();
    const dt = Math.min(0.1, (now - this.lastTime) / 1000);
    this.lastTime = now;
    
    if (!this.paused) {
      // Calculate flows in the network
      this.flowNetwork.calculateFlows(dt);
      
      // Update all components
      this.flowNetwork.updateComponents(dt);
      
      // Render all components
      this.flowNetwork.renderComponents();
    }
    
    // Continue loop
    requestAnimationFrame(() => this._simulationLoop());
  }

  /**
   * Reset all components
   */
  reset() {
    this.flowNetwork.reset();
    
    if (this.tankManager) this.tankManager.reset();
    if (this.pumpManager) this.pumpManager.reset();
    if (this.valveManager) this.valveManager.reset();
    if (this.pipeManager) this.pipeManager.reset();
    if (this.pressureManager) this.pressureManager.reset();
    
    // Reset boundaries
    for (const feed of Object.values(this.feeds)) {
      feed.reset();
    }
    for (const drain of Object.values(this.drains)) {
      drain.reset();
    }
    
    console.log('All components reset');
  }

  /**
   * Get component by ID
   */
  getComponent(id) {
    return this.flowNetwork.getComponent(id);
  }

  /**
   * Get system info
   */
  getSystemInfo() {
    return {
      running: this.running,
      paused: this.paused,
      network: this.flowNetwork.getNetworkInfo(),
      managers: {
        feeds: Object.keys(this.feeds).length,
        tanks: this.tankManager ? Object.keys(this.tankManager.tanks || {}).length : 0,
        pumps: this.pumpManager ? Object.keys(this.pumpManager.pumps || {}).length : 0,
        valves: this.valveManager ? Object.keys(this.valveManager.valves || {}).length : 0,
        drains: Object.keys(this.drains).length,
        pipes: this.pipeManager ? Object.keys(this.pipeManager.pipes || {}).length : 0,
        pressureSensors: this.pressureManager ? Object.keys(this.pressureManager.sensors || {}).length : 0
      }
    };
  }

  /**
   * Destroy and cleanup
   */
  destroy() {
    this.stop();
    
    if (this.tankManager) this.tankManager.destroy();
    if (this.pumpManager) this.pumpManager.destroy();
    if (this.valveManager) this.valveManager.destroy();
    if (this.pipeManager) this.pipeManager.destroy();
    if (this.pressureManager) this.pressureManager.destroy();
    
    for (const feed of Object.values(this.feeds)) {
      feed.destroy();
    }
    for (const drain of Object.values(this.drains)) {
      drain.destroy();
    }
    
    this.flowNetwork.clear();
    
    console.log('ComponentManager destroyed');
  }
}

// Export
window.ComponentManager = ComponentManager;


/**
 * version.js - Engine Version Declaration and Compatibility Checking
 * 
 * Place this file in: engine/core/version.js
 * Load it FIRST in all simulator HTML files
 */

// Engine version
window.ENGINE_VERSION = '1.0.0';

// Compatibility checking
window.EngineCompat = {
  
  /**
   * Check if config is compatible with current engine
   */
  checkCompatibility(config) {
    if (!config || !config._metadata) {
      console.warn('‚ö†Ô∏è Config missing metadata - compatibility unknown');
      return { compatible: true, warnings: ['Config missing version metadata'] };
    }
    
    const configVersion = config._metadata.version;
    const engineVersion = window.ENGINE_VERSION;
    
    const warnings = [];
    const errors = [];
    
    // Parse versions
    const configParts = configVersion.split('.').map(Number);
    const engineParts = engineVersion.split('.').map(Number);
    
    // Major version must match
    if (configParts[0] !== engineParts[0]) {
      errors.push(`Major version mismatch: Config v${configVersion}, Engine v${engineVersion}`);
      errors.push('This simulator may not work correctly. Update either the config or engine.');
    }
    
    // Minor version mismatch is a warning
    else if (configParts[1] !== engineParts[1]) {
      warnings.push(`Minor version mismatch: Config v${configVersion}, Engine v${engineVersion}`);
      warnings.push('Some features may not work as expected.');
    }
    
    // Patch version difference is OK
    else if (configParts[2] !== engineParts[2]) {
      console.log(`‚ÑπÔ∏è Patch version difference: Config v${configVersion}, Engine v${engineVersion} (OK)`);
    }
    
    return {
      compatible: errors.length === 0,
      warnings,
      errors,
      configVersion,
      engineVersion
    };
  },
  
  /**
   * Display compatibility report
   */
  showCompatibilityReport(result) {
    if (result.errors.length > 0) {
      console.error('‚ùå COMPATIBILITY ERRORS:');
      result.errors.forEach(err => console.error('  - ' + err));
      
      // Show alert to user
      alert(`‚ùå Version Incompatibility\n\n${result.errors.join('\n')}\n\nSimulator may not work correctly.`);
    }
    
    if (result.warnings.length > 0) {
      console.warn('‚ö†Ô∏è COMPATIBILITY WARNINGS:');
      result.warnings.forEach(warn => console.warn('  - ' + warn));
    }
    
    if (result.compatible && result.warnings.length === 0) {
      console.log('‚úÖ Version compatibility: OK');
    }
  },
  
  /**
   * Get feature compatibility matrix
   */
  getFeatureSupport() {
    return {
      '1.0.0': {
        pumps: ['fixed', 'variable', '3-speed'],
        valves: ['proportional'],
        tanks: ['basic'],
        pipes: ['basic'],
        sensors: ['pressure'],
        features: ['cavitation', 'modal-controls']
      }
      // Add new versions here as engine evolves
    };
  },
  
  /**
   * Check if specific feature is supported
   */
  supportsFeature(feature) {
    const support = this.getFeatureSupport();
    const version = window.ENGINE_VERSION;
    
    if (!support[version]) {
      console.warn(`No feature data for engine v${version}`);
      return false;
    }
    
    // Check all feature arrays
    for (const [category, items] of Object.entries(support[version])) {
      if (Array.isArray(items) && items.includes(feature)) {
        return true;
      }
    }
    
    return false;
  }
};

// Auto-check on load if config is already present
if (typeof window !== 'undefined') {
  window.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      if (window.SYSTEM_CONFIG) {
        const result = window.EngineCompat.checkCompatibility(window.SYSTEM_CONFIG);
        window.EngineCompat.showCompatibilityReport(result);
      }
    }, 100);
  });
}

console.log(`‚úÖ Engine v${window.ENGINE_VERSION} loaded`);


/**
 * Feed.js - Source/inlet boundary condition component
 * 
 * Represents an infinite supply (e.g., water main, process feed)
 * Has no inputs, provides flow to downstream components
 */

class Feed extends Component {
  constructor(config) {
    super(config);
    
    this.type = 'feed';
    
    // Boundary condition properties
    this.supplyPressure = config.supplyPressure || 3.0; // bar (typical water main)
    this.maxFlow = config.maxFlow || Infinity; // m¬≥/s (unlimited by default)
    this.temperature = config.temperature || 20; // ¬∞C (for future use)
    
    // Supply characteristics
    this.available = config.available !== false; // Can be shut off
    this.flowRate = 0; // Current flow rate (determined by downstream demand)
    
    console.log(`Feed created: ${this.name} (${this.supplyPressure} bar, max ${this.maxFlow === Infinity ? 'unlimited' : this.maxFlow + ' m¬≥/s'})`);
  }

  /**
   * Feed supplies flow based on downstream demand
   * Infinite source, but can be limited by maxFlow
   */
  getOutputFlow() {
    if (!this.available) return 0;
    
    // Feed provides whatever downstream needs, up to maxFlow
    // (Downstream components like valves will limit actual flow)
    return this.maxFlow;
  }

  /**
   * Get supply pressure (for future pressure-based calculations)
   */
  getSupplyPressure() {
    return this.available ? this.supplyPressure : 0;
  }

  /**
   * Enable/disable feed
   */
  setAvailable(available) {
    this.available = !!available;
    this.notifyChange();
    console.log(`${this.name} ${this.available ? 'enabled' : 'disabled'}`);
  }

  /**
   * Update feed state
   */
  update(dt) {
    // Track actual flow rate (read from network)
    if (this.flowNetwork) {
      this.flowRate = this.flowNetwork.getOutputFlow(this.id);
    }
  }

  /**
   * Render (feeds are typically non-visual)
   */
  render() {
    // Feed has no visual representation in this version
    // Could add a supply indicator icon in future
  }

  /**
   * Reset feed
   */
  reset() {
    super.reset();
    this.available = true;
    this.flowRate = 0;
  }

  /**
   * Check if feed is a boundary node
   */
  isBoundary() {
    return true;
  }

  /**
   * Get feed info
   */
  getInfo() {
    return {
      ...super.getInfo(),
      available: this.available,
      supplyPressure: this.supplyPressure + ' bar',
      maxFlow: this.maxFlow === Infinity ? 'unlimited' : this.maxFlow + ' m¬≥/s',
      currentFlow: this.flowRate.toFixed(3) + ' m¬≥/s',
      temperature: this.temperature + ' ¬∞C'
    };
  }
}

// Export
window.Feed = Feed;


/**
 * Drain.js - Sink/outlet boundary condition component
 * 
 * Represents infinite discharge capacity (e.g., sewer, process outlet)
 * Has inputs, no outputs, accepts any flow
 */

class Drain extends Component {
  constructor(config) {
    super(config);
    
    this.type = 'drain';
    
    // Boundary condition properties
    this.ambientPressure = config.ambientPressure || 1.0; // bar (atmospheric)
    this.maxCapacity = config.maxCapacity || Infinity; // m¬≥/s (unlimited by default)
    this.backpressure = config.backpressure || 0; // bar (resistance, for future use)
    
    // Discharge characteristics
    this.open = config.open !== false; // Can be closed
    this.flowRate = 0; // Current flow rate
    this.totalDischarge = 0; // Cumulative volume discharged (m¬≥)
    
    console.log(`Drain created: ${this.name} (${this.ambientPressure} bar, capacity ${this.maxCapacity === Infinity ? 'unlimited' : this.maxCapacity + ' m¬≥/s'})`);
  }

  /**
   * Drain accepts infinite flow (is a sink)
   */
  getOutputFlow() {
    return 0; // Sinks don't output
  }

  /**
   * Get ambient pressure at drain (for future pressure-based calculations)
   */
  getAmbientPressure() {
    return this.open ? this.ambientPressure : Infinity; // Infinite resistance if closed
  }

  /**
   * Get backpressure (resistance to flow)
   */
  getBackpressure() {
    return this.open ? this.backpressure : Infinity;
  }

  /**
   * Open/close drain
   */
  setOpen(open) {
    this.open = !!open;
    this.notifyChange();
    console.log(`${this.name} ${this.open ? 'opened' : 'closed'}`);
  }

  /**
   * Update drain state
   */
  update(dt) {
    // Track actual flow rate (read from network)
    if (this.flowNetwork) {
      this.flowRate = this.flowNetwork.getInputFlow(this.id);
      
      // Accumulate total discharge
      this.totalDischarge += this.flowRate * dt;
    }
  }

  /**
   * Render (drains are typically non-visual)
   */
  render() {
    // Drain has no visual representation in this version
    // Could add a discharge indicator icon in future
  }

  /**
   * Reset drain
   */
  reset() {
    super.reset();
    this.open = true;
    this.flowRate = 0;
    this.totalDischarge = 0;
  }

  /**
   * Check if drain is a boundary node
   */
  isBoundary() {
    return true;
  }

  /**
   * Get drain info
   */
  getInfo() {
    return {
      ...super.getInfo(),
      open: this.open,
      ambientPressure: this.ambientPressure + ' bar',
      maxCapacity: this.maxCapacity === Infinity ? 'unlimited' : this.maxCapacity + ' m¬≥/s',
      currentFlow: this.flowRate.toFixed(3) + ' m¬≥/s',
      totalDischarge: this.totalDischarge.toFixed(3) + ' m¬≥',
      backpressure: this.backpressure + ' bar'
    };
  }
}

// Export
window.Drain = Drain;


/**
 * Pump.js - Base pump component with proper flow constraints
 * 
 * Pump reads available supply from tank and constrains by valve position
 */

class Pump extends Component {
  constructor(config) {
    super(config);
    
    this.type = 'pump';
    this.pumpType = config.pumpType || 'fixed';
    
    // Physical properties
    this.capacity = config.capacity || 1.0;
    this.efficiency = config.efficiency || 0.95;
    this.power = config.power || 0;
    
    // Operating state
    this.running = false;
    this.speed = config.initialSpeed || 0;
    this.requiresMinLevel = config.requiresMinLevel || 0;
    
    // Cavitation
    this.cavitation = {
      enabled: config.cavitation?.enabled || false,
      triggerTime: config.cavitation?.triggerTime || 60,
      duration: config.cavitation?.duration || 5,
      flowReduction: config.cavitation?.flowReduction || 0.3,
      active: false,
      startTime: null,
      elapsedTime: 0
    };
    
    // Tracking
    this.runTime = 0;
    this.startCount = 0;
  }

  start() {
    if (this.running) return;
    
    this.running = true;
    this.startCount++;
    
    if (this.cavitation.enabled && this.cavitation.triggerTime === null) {
      this._startCavitation();
    }
    
    this.notifyChange();
    console.log(`${this.name} started (start count: ${this.startCount})`);
  }

  stop() {
    if (!this.running) return;
    
    this.running = false;
    this.cavitation.active = false;
    this.cavitation.startTime = null;
    
    this.notifyChange();
    console.log(`${this.name} stopped`);
  }

  setSpeed(speed) {
    this.speed = Math.max(0, Math.min(1, speed));
    this.notifyChange();
  }

  canRun(sourceLevel) {
    if (sourceLevel === undefined) return true;
    return sourceLevel >= this.requiresMinLevel;
  }

  _startCavitation() {
    if (!this.cavitation.enabled) return;
    
    this.cavitation.active = true;
    this.cavitation.startTime = performance.now();
    console.warn(`‚ö†Ô∏è ${this.name} CAVITATION STARTED!`);
  }

  _updateCavitation(dt) {
    if (!this.cavitation.enabled || !this.running) return;
    
    this.cavitation.elapsedTime += dt;
    
    if (!this.cavitation.active && 
        this.cavitation.triggerTime !== null && 
        this.cavitation.elapsedTime >= this.cavitation.triggerTime) {
      this._startCavitation();
    }
    
    if (this.cavitation.active) {
      const cavitationDuration = (performance.now() - this.cavitation.startTime) / 1000;
      if (cavitationDuration >= this.cavitation.duration) {
        this.cavitation.active = false;
        this.cavitation.startTime = null;
        console.log(`${this.name} cavitation ended`);
      }
    }
  }

  /**
   * SMART OUTPUT: Pump constrains flow based on:
   * 1. Available supply from tank (read from network)
   * 2. Pump capacity
   * 3. Downstream valve position
   */
getOutputFlow() {
  if (!this.running) return 0;
  
  let maxFlow = this.capacity * this.speed * this.efficiency;
  
  if (this.cavitation.active) {
    maxFlow *= this.cavitation.flowReduction;
  }
  
  if (!this.flowNetwork) return maxFlow;
  
  // CONSTRAINT 1: Check tank availability
  let availableFromTank = Infinity;
  let tankComponent = null;
  
  for (const inputId of this.inputs) {
    const tank = this._findUpstreamComponent(inputId, 'tank');
    if (tank) {
      tankComponent = tank;
      // Tank can supply based on current volume (50% per second max)
      availableFromTank = Math.min(availableFromTank, tank.volume * 0.5);
      
      if (tank.level < this.requiresMinLevel) {
        console.warn(`${this.name} stopped - tank level below minimum`);
        return 0;
      }
    }
  }
  
  // CONSTRAINT 2: Check valve
  let valveLimit = Infinity;
  for (const outputId of this.outputs) {
    const valve = this._findDownstreamComponent(outputId, 'valve');
    if (valve) {
      valveLimit = Math.min(valveLimit, valve.maxFlow * valve.position);
    }
  }
  
  // Actual flow = minimum of all constraints
  const actualFlow = Math.min(maxFlow, availableFromTank, valveLimit);
  
  // CRITICAL: Create the tank->pump flow so tank drains correctly
  if (tankComponent && actualFlow > 0) {
    this.flowNetwork.setFlow(tankComponent.id, this.id, actualFlow);
  }
  
  return actualFlow;
}

  /**
   * Helper: Find upstream component by type (looks through pipes)
   */
  _findUpstreamComponent(startId, targetType) {
    if (!this.flowNetwork) return null;
    
    const component = this.flowNetwork.getComponent(startId);
    if (!component) return null;
    
    if (component.type === targetType) return component;
    
    if (component.type === 'pipe' && component.inputs && component.inputs.length > 0) {
      for (const inputId of component.inputs) {
        const result = this._findUpstreamComponent(inputId, targetType);
        if (result) return result;
      }
    }
    
    return null;
  }

  /**
   * Helper: Find downstream component by type (looks through pipes)
   */
  _findDownstreamComponent(startId, targetType) {
    if (!this.flowNetwork) return null;
    
    const component = this.flowNetwork.getComponent(startId);
    if (!component) return null;
    
    if (component.type === targetType) return component;
    
    if (component.type === 'pipe' && component.outputs && component.outputs.length > 0) {
      for (const outputId of component.outputs) {
        const result = this._findDownstreamComponent(outputId, targetType);
        if (result) return result;
      }
    }
    
    return null;
  }

  update(dt) {
    if (!this.running) return;
    
    this.runTime += dt;
    this._updateCavitation(dt);
  }

  reset() {
    super.reset();
    this.running = false;
    this.speed = 0;
    this.runTime = 0;
    this.startCount = 0;
    this.cavitation.active = false;
    this.cavitation.startTime = null;
    this.cavitation.elapsedTime = 0;
  }

  getInfo() {
    return {
      ...super.getInfo(),
      pumpType: this.pumpType,
      running: this.running,
      speed: this.speed,
      capacity: this.capacity,
      outputFlow: this.getOutputFlow(),
      cavitation: this.cavitation.active,
      runTime: this.runTime.toFixed(1),
      startCount: this.startCount
    };
  }
}

// Export
window.Pump = Pump;


/**
 * FixedSpeedPump.js - Fixed speed pump (ON/OFF only)
 * 
 * Simple pump with just two states: ON or OFF
 */

class FixedSpeedPump extends Pump {
  constructor(config) {
    super({
      ...config,
      pumpType: 'fixed'
    });
    
    // Fixed speed pumps always run at 100% when ON
    this.speed = 1.0;
  }

  /**
   * Start pump (always at full speed)
   */
  start() {
    this.speed = 1.0;
    super.start();
  }

  /**
   * Stop pump
   */
  stop() {
    this.speed = 0;
    super.stop();
  }

  /**
   * Toggle pump ON/OFF
   */
  toggle() {
    if (this.running) {
      this.stop();
    } else {
      this.start();
    }
  }

  /**
   * Fixed speed pumps don't allow speed changes
   */
  setSpeed(speed) {
    console.warn(`${this.name} is a fixed speed pump - speed cannot be adjusted`);
    this.speed = this.running ? 1.0 : 0;
  }
}

// Export
window.FixedSpeedPump = FixedSpeedPump;


/**
 * VariableSpeedPump.js - Variable speed pump (0-100% control)
 * 
 * Pump with continuous speed control via slider
 */

class VariableSpeedPump extends Pump {
  constructor(config) {
    super({
      ...config,
      pumpType: 'variable'
    });
    
    // Variable speed pumps can run at any speed 0-100%
    this.minSpeed = config.minSpeed || 0.1; // Minimum operating speed (10%)
    this.speed = config.initialSpeed || 0;
  }

  /**
   * Start pump at current speed
   */
  start() {
    // If speed is too low, start at minimum speed
    if (this.speed < this.minSpeed) {
      this.speed = this.minSpeed;
    }
    super.start();
  }

  /**
   * Stop pump (speed goes to 0)
   */
  stop() {
    this.speed = 0;
    super.stop();
  }

  /**
   * Set pump speed (0-1)
   */
  setSpeed(speed) {
    // Clamp speed to valid range
    speed = Math.max(0, Math.min(1, speed));
    
    // If pump is running, enforce minimum speed
    if (this.running && speed > 0 && speed < this.minSpeed) {
      speed = this.minSpeed;
    }
    
    this.speed = speed;
    
    // Auto-start if speed > 0 and pump not running
    if (speed > 0 && !this.running) {
      super.start();
    }
    
    // Auto-stop if speed = 0 and pump running
    if (speed === 0 && this.running) {
      super.stop();
    }
    
    this.notifyChange();
  }

  /**
   * Increase speed by amount
   */
  increaseSpeed(amount = 0.1) {
    this.setSpeed(this.speed + amount);
  }

  /**
   * Decrease speed by amount
   */
  decreaseSpeed(amount = 0.1) {
    this.setSpeed(this.speed - amount);
  }

  /**
   * Get speed percentage (0-100)
   */
  getSpeedPercent() {
    return Math.round(this.speed * 100);
  }
}

// Export
window.VariableSpeedPump = VariableSpeedPump;


/**
 * ThreeSpeedPump.js - Three-speed pump (Low/Med/High)
 * 
 * Pump with three discrete speed settings
 */

class ThreeSpeedPump extends Pump {
  constructor(config) {
    super({
      ...config,
      pumpType: '3-speed'
    });
    
    // Three discrete speed levels
    this.speeds = config.speeds || [0.3, 0.6, 1.0]; // Low, Med, High
    this.speedNames = ['Low', 'Medium', 'High'];
    this.currentSpeedIndex = 0; // 0 = Low, 1 = Med, 2 = High
    
    // Set initial speed
    if (config.initialSpeed !== undefined) {
      this.setSpeedIndex(config.initialSpeed);
    } else {
      this.speed = 0;
    }
  }

  /**
   * Start pump at current speed setting
   */
  start() {
    // If speed is 0, start at low speed
    if (this.speed === 0) {
      this.setSpeedIndex(0);
    }
    super.start();
  }

  /**
   * Stop pump
   */
  stop() {
    super.stop();
  }

  /**
   * Set speed by index (0, 1, or 2)
   */
  setSpeedIndex(index) {
    index = Math.max(0, Math.min(2, index));
    this.currentSpeedIndex = index;
    this.speed = this.speeds[index];
    
    // Auto-start if not running
    if (!this.running) {
      super.start();
    }
    
    this.notifyChange();
    console.log(`${this.name} set to ${this.speedNames[index]} (${(this.speed * 100).toFixed(0)}%)`);
  }

  /**
   * Set to Low speed
   */
  setLow() {
    this.setSpeedIndex(0);
  }

  /**
   * Set to Medium speed
   */
  setMedium() {
    this.setSpeedIndex(1);
  }

  /**
   * Set to High speed
   */
  setHigh() {
    this.setSpeedIndex(2);
  }

  /**
   * Cycle to next speed
   */
  nextSpeed() {
    this.setSpeedIndex((this.currentSpeedIndex + 1) % 3);
  }

  /**
   * Cycle to previous speed
   */
  previousSpeed() {
    this.setSpeedIndex((this.currentSpeedIndex - 1 + 3) % 3);
  }

  /**
   * Get current speed name
   */
  getSpeedName() {
    return this.speedNames[this.currentSpeedIndex];
  }

  /**
   * Get current speed index (0, 1, or 2)
   */
  getSpeedIndex() {
    return this.currentSpeedIndex;
  }

  /**
   * Override setSpeed to snap to nearest discrete speed
   */
  setSpeed(speed) {
    // Find nearest speed
    let nearestIndex = 0;
    let minDiff = Math.abs(speed - this.speeds[0]);
    
    for (let i = 1; i < this.speeds.length; i++) {
      const diff = Math.abs(speed - this.speeds[i]);
      if (diff < minDiff) {
        minDiff = diff;
        nearestIndex = i;
      }
    }
    
    this.setSpeedIndex(nearestIndex);
  }

  /**
   * Get pump info
   */
  getInfo() {
    return {
      ...super.getInfo(),
      speedSetting: this.getSpeedName(),
      speedIndex: this.currentSpeedIndex
    };
  }
}

// Export
window.ThreeSpeedPump = ThreeSpeedPump;


/**
 * Valve.js - Valve component with proportional control
 * 
 * Supports 0-100% positioning via interactive wheel control
 */

class Valve extends Component {
  constructor(config) {
    super(config);
    
    this.type = 'valve';
    
    // Physical properties
    this.maxFlow = config.maxFlow || 1.0; // Max flow rate when fully open (m¬≥/s)
    
    // Operating state
    this.position = config.initialPosition || 0; // 0 = closed, 1 = fully open
    
    // Valve characteristics
    this.responseTime = config.responseTime || 0.1; // Time to change position (seconds)
    this.targetPosition = this.position; // Target position for smooth transitions
    
    console.log(`Valve created: ${this.name} (max flow: ${this.maxFlow})`);
  }

  /**
   * Set valve position (0-1)
   */
  setPosition(pos) {
    pos = Math.max(0, Math.min(1, pos));
    this.targetPosition = pos;
    this.notifyChange();
  }

  /**
   * Get current valve position (0-1)
   */
  getPosition() {
    return this.position;
  }

  /**
   * Get position as percentage (0-100)
   */
  getPositionPercent() {
    return Math.round(this.position * 100);
  }

  /**
   * Open valve fully
   */
  open() {
    this.setPosition(1.0);
  }

  /**
   * Close valve fully
   */
  close() {
    this.setPosition(0);
  }

  /**
   * Check if valve is open (>5%)
   */
  isOpen() {
    return this.position > 0.05;
  }

  /**
   * Check if valve is closed (<5%)
   */
  isClosed() {
    return this.position < 0.05;
  }

  /**
   * Check if valve is fully open (>95%)
   */
  isFullyOpen() {
    return this.position > 0.95;
  }

  /**
   * Get current flow rate through valve
   */
  getOutputFlow() {
    // Flow is proportional to valve position
    return this.maxFlow * this.position;
  }

  /**
   * Update valve state (smooth position transitions)
   */
  update(dt) {
    // Smooth transition to target position
    if (Math.abs(this.position - this.targetPosition) > 0.001) {
      const delta = this.targetPosition - this.position;
      const step = (delta / this.responseTime) * dt;
      
      this.position += step;
      this.position = Math.max(0, Math.min(1, this.position));
      
      // Snap to target if very close
      if (Math.abs(this.position - this.targetPosition) < 0.001) {
        this.position = this.targetPosition;
      }
    }
  }

  /**
   * Reset valve
   */
  reset() {
    super.reset();
    this.position = 0;
    this.targetPosition = 0;
  }

  /**
   * Get valve info
   */
  getInfo() {
    return {
      ...super.getInfo(),
      position: this.position,
      positionPercent: this.getPositionPercent() + '%',
      targetPosition: this.targetPosition,
      maxFlow: this.maxFlow,
      currentFlow: this.getOutputFlow().toFixed(3),
      status: this.isClosed() ? 'CLOSED' : this.isFullyOpen() ? 'OPEN' : 'PARTIAL'
    };
  }
}

// Export
window.Valve = Valve;


class Tank extends Component {
  constructor(config) {
    super(config);
    this.type = 'tank';
    this.area = config.area || 1.0;
    this.maxHeight = config.maxHeight || 1.0;
    this.maxVolume = this.area * this.maxHeight;
    this.volume = config.initialVolume || 0;
    this.level = this.volume / this.maxVolume;
    this.levelRect = null;
    this.levelRectHeight = config.levelRectHeight || 360;
    this.levelRectY = config.levelRectY || 360;
    this.lowThreshold = config.lowThreshold || 0.1;
    this.highThreshold = config.highThreshold || 0.9;
    this.lastInputFlow = 0;
    this.lastOutputFlow = 0;
    this._initializeVisuals();
    console.log('Tank created: ' + this.name);
  }

  _initializeVisuals() {
    const element = this.getElement();
    if (!element) return;
    this.levelRect = element.querySelector('#levelRect') || element.querySelector('.levelRect');
    if (!this.levelRect) {
      console.warn('Level rect not found for tank ' + this.name);
    }
  }

  getOutputFlow() {
    return 0;
  }

  update(dt) {
    const Qin = this.flowNetwork ? this.flowNetwork.getInputFlow(this.id) : 0;
    const Qout = this.flowNetwork ? this.flowNetwork.getOutputFlow(this.id) : 0;
    this.lastInputFlow = Qin;
    this.lastOutputFlow = Qout;
    const dV = (Qin - Qout) * dt;
    this.volume += dV;
    this.volume = Math.max(0, Math.min(this.maxVolume, this.volume));
    this.level = this.volume / this.maxVolume;
  }

  render() {
    if (!this.levelRect) return;
    const heightPx = this.levelRectHeight * this.level;
    const yPx = this.levelRectY - heightPx;
    this.levelRect.setAttribute('height', heightPx);
    this.levelRect.setAttribute('y', yPx);
    if (this.level < this.lowThreshold) {
      this.levelRect.setAttribute('opacity', '0.6');
    } else if (this.level > this.highThreshold) {
      this.levelRect.setAttribute('opacity', '1.0');
    } else {
      this.levelRect.setAttribute('opacity', '0.8');
    }
  }

  getLevel() {
    return this.level;
  }

  getLevelPercent() {
    return Math.round(this.level * 100);
  }

  isEmpty() {
    return this.volume < 0.001;
  }

  isFull() {
    return this.volume >= this.maxVolume - 0.001;
  }

  isLow() {
    return this.level < this.lowThreshold;
  }

  isHigh() {
    return this.level > this.highThreshold;
  }

  setVolume(volume) {
    this.volume = Math.max(0, Math.min(this.maxVolume, volume));
    this.level = this.volume / this.maxVolume;
    this.notifyChange();
  }

  setLevelPercent(percent) {
    const fraction = Math.max(0, Math.min(100, percent)) / 100;
    this.setVolume(fraction * this.maxVolume);
  }

  reset() {
    super.reset();
    this.volume = 0;
    this.level = 0;
    this.lastInputFlow = 0;
    this.lastOutputFlow = 0;
  }

  getInfo() {
    return {
      ...super.getInfo(),
      volume: this.volume.toFixed(3) + ' m¬≥',
      level: this.getLevelPercent() + '%',
      maxVolume: this.maxVolume.toFixed(2) + ' m¬≥',
      inputFlow: this.lastInputFlow.toFixed(3) + ' m¬≥/s',
      outputFlow: this.lastOutputFlow.toFixed(3) + ' m¬≥/s',
      status: this.isEmpty() ? 'EMPTY' : this.isFull() ? 'FULL' : this.isLow() ? 'LOW' : this.isHigh() ? 'HIGH' : 'NORMAL'
    };
  }
}

window.Tank = Tank;


/**
 * Pipe.js - Visual-only pipe component
 * 
 * Pipes READ flows from the network (they don't create flows)
 * They animate based on actual component-to-component flows
 */

class Pipe extends Component {
  constructor(config) {
    super(config);
    
    this.type = 'pipe';
    
    // Physical properties
    this.diameter = config.diameter || 0.05; // meters (50mm default)
    this.length = config.length || 1.0; // meters
    this.roughness = config.roughness || 0.000045; // meters (steel pipe)
    
    // Flow state (read from network, not calculated here)
    this.flowRate = 0; // m¬≥/s
    this.velocity = 0; // m/s
    this.reynoldsNumber = 0;
    this.regime = 'Laminar'; // 'Laminar', 'Transitional', 'Turbulent'
    
    // Animation state
    this.animating = false;
    
    // Visual element
    this.flowPath = null;
    
    this._initializeVisuals();
    
    console.log(`Pipe created: ${this.name} (${this.diameter * 1000}mm √ó ${this.length}m)`);
  }

  _initializeVisuals() {
    const element = this.getElement();
    if (element) {
      this.flowPath = element;
    } else if (this.svgElement) {
      this.flowPath = document.querySelector(this.svgElement);
    }
    
    if (!this.flowPath) {
      console.warn(`Flow path not found for pipe ${this.name}`);
    }
  }

  /**
   * CRITICAL: Pipes DON'T create flow - they only visualize it
   */
  getOutputFlow() {
    return 0; // Pipes never processed in calculateFlows
  }

  /**
   * Update pipe state - READ flow from network
   */
  update(dt) {
    if (!this.flowNetwork) return;
    
    // READ the actual flow between the components this pipe connects
    // Example: pipe2 connects inletValve ‚Üí tank1
    // So we read the flow from inletValve to tank1
    
    if (this.inputs.length > 0 && this.outputs.length > 0) {
      const fromId = this.inputs[0];
      const toId = this.outputs[0];
      
      // Read flow from network
      this.flowRate = this.flowNetwork.getFlow(fromId, toId);
    } else {
      this.flowRate = 0;
    }
    
    // Calculate derived properties
    this._calculateFlowProperties();
    
    // Update animation state
    this._updateAnimation();
  }

  /**
   * Calculate flow properties (velocity, Reynolds number, regime)
   */
  _calculateFlowProperties() {
    // Cross-sectional area
    const area = Math.PI * Math.pow(this.diameter / 2, 2);
    
    // Velocity: v = Q / A
    this.velocity = area > 0 ? this.flowRate / area : 0;
    
    // Reynolds number: Re = œÅ * v * D / Œº
    // For water at 20¬∞C: œÅ = 1000 kg/m¬≥, Œº = 0.001 Pa¬∑s
    const density = 1000; // kg/m¬≥
    const viscosity = 0.001; // Pa¬∑s
    
    this.reynoldsNumber = (density * this.velocity * this.diameter) / viscosity;
    
    // Flow regime
    if (this.reynoldsNumber < 2300) {
      this.regime = 'Laminar';
    } else if (this.reynoldsNumber < 4000) {
      this.regime = 'Transitional';
    } else {
      this.regime = 'Turbulent';
    }
  }

  /**
   * Update animation based on flow rate
   */
  _updateAnimation() {
    if (!this.flowPath) return;
    
    const hasFlow = this.flowRate > 0.001; // Threshold to avoid noise
    
    if (hasFlow) {
      // Start animation
      if (!this.animating) {
        this.flowPath.classList.add('on');
        this.animating = true;
      }
      
      // Adjust animation speed based on flow rate
      // Higher flow = faster animation
      // Speed range: 200ms (fast) to 2000ms (slow)
      const maxFlow = 1.0; // m¬≥/s (assumed max for scaling)
      const normalizedFlow = Math.min(1, this.flowRate / maxFlow);
      const duration = 2000 - (1800 * normalizedFlow); // 2000ms to 200ms
      
      this.flowPath.style.setProperty('--duration', `${duration}ms`);
    } else {
      // Stop animation
      if (this.animating) {
        this.flowPath.classList.remove('on');
        this.animating = false;
      }
    }
  }

  /**
   * Render pipe visual state
   */
  render() {
    // Animation is handled by CSS and update()
    // Could add color coding based on flow rate or regime here
    
    if (!this.flowPath) return;
    
    // Optional: Change color based on regime
    if (this.flowRate > 0) {
      if (this.regime === 'Turbulent') {
        // Could add a class for turbulent flow visualization
      }
    }
  }

  /**
   * Get flow velocity
   */
  getVelocity() {
    return this.velocity;
  }

  /**
   * Get Reynolds number
   */
  getReynoldsNumber() {
    return this.reynoldsNumber;
  }

  /**
   * Get flow regime
   */
  getFlowRegime() {
    return this.regime;
  }

  /**
   * Check if pipe is flowing
   */
  isFlowing() {
    return this.flowRate > 0.001;
  }

  /**
   * Calculate pressure drop (for future use)
   */
  getPressureDrop() {
    // Darcy-Weisbach equation: ŒîP = f * (L/D) * (œÅv¬≤/2)
    // Simplified for now
    
    if (this.velocity === 0) return 0;
    
    // Friction factor (simplified - use Moody chart for accuracy)
    let frictionFactor;
    if (this.reynoldsNumber < 2300) {
      // Laminar: f = 64/Re
      frictionFactor = 64 / this.reynoldsNumber;
    } else {
      // Turbulent: Colebrook-White (simplified)
      frictionFactor = 0.02; // Approximation
    }
    
    const density = 1000; // kg/m¬≥
    const pressureDrop = frictionFactor * 
                        (this.length / this.diameter) * 
                        (density * Math.pow(this.velocity, 2) / 2);
    
    return pressureDrop / 100000; // Convert Pa to bar
  }

  /**
   * Reset pipe
   */
  reset() {
    super.reset();
    this.flowRate = 0;
    this.velocity = 0;
    this.reynoldsNumber = 0;
    this.regime = 'Laminar';
    this.animating = false;
    
    if (this.flowPath) {
      this.flowPath.classList.remove('on');
    }
  }

  /**
   * Get pipe info
   */
  getInfo() {
    return {
      ...super.getInfo(),
      flowRate: this.flowRate.toFixed(3) + ' m¬≥/s',
      velocity: this.velocity.toFixed(2) + ' m/s',
      reynolds: Math.round(this.reynoldsNumber),
      regime: this.regime,
      diameter: (this.diameter * 1000).toFixed(0) + ' mm',
      length: this.length.toFixed(1) + ' m',
      pressureDrop: this.getPressureDrop().toFixed(3) + ' bar',
      animating: this.animating
    };
  }
}

// Export
window.Pipe = Pipe;


/**
 * PressureSensor.js - Pressure sensor component
 * 
 * Monitors pressure at any point in the system
 */

class PressureSensor extends Component {
  constructor(config) {
    super(config);
    
    this.type = 'sensor';
    this.sensorType = 'pressure';
    
    // Measurement properties
    this.range = config.range || [0, 10]; // [min, max] in bar
    this.units = config.units || 'bar';
    this.accuracy = config.accuracy || 0.01; // Reading precision
    
    // Location in system
    this.measurementPoint = config.measurementPoint || 'static'; // 'static', 'pump_inlet', 'pump_outlet', 'tank_bottom'
    this.heightOffset = config.heightOffset || 0; // Height above datum (m)
    
    // Current reading
    this.pressure = 0; // Current pressure reading (bar)
    this.trend = 0; // Rate of change (bar/s)
    this.previousPressure = 0;
    
    // Alarm thresholds
    this.lowAlarm = config.lowAlarm || null; // Low pressure alarm (bar)
    this.highAlarm = config.highAlarm || null; // High pressure alarm (bar)
    this.alarmActive = false;
    
    // Physical constants
    this.fluidDensity = config.fluidDensity || 1000; // kg/m¬≥ (water)
    this.gravity = config.gravity || 9.81; // m/s¬≤
    
    // Visual gauge element
    this.gaugeElement = null;
    
    this._initializeVisuals();
    
    console.log(`Pressure sensor created: ${this.name} (${this.range[0]}-${this.range[1]} ${this.units})`);
  }

  /**
   * Initialize visual elements
   */
  _initializeVisuals() {
    const element = this.getElement();
    if (element) {
      this.gaugeElement = element.querySelector('.pressure-gauge');
    }
  }

  /**
   * Calculate pressure based on sensor location and system state
   */
  calculatePressure() {
    let pressure = 0; // in Pascals
    
    switch (this.measurementPoint) {
      case 'atmospheric':
        // Atmospheric pressure (1 bar = 100,000 Pa)
        pressure = 101325; // Pa (1 atm)
        break;
        
      case 'tank_bottom':
        // Static pressure from liquid column: P = œÅgh
        const tank = this._getTankFromInputs();
        if (tank) {
          const liquidHeight = tank.level * tank.maxHeight; // meters
          pressure = this.fluidDensity * this.gravity * liquidHeight;
          pressure += 101325; // Add atmospheric
        } else {
          pressure = 101325; // Just atmospheric if no tank
        }
        break;
        
      case 'pump_inlet':
        // Suction pressure (may be below atmospheric)
        const sourceTank = this._getTankFromInputs();
        if (sourceTank) {
          const liquidHeight = sourceTank.level * sourceTank.maxHeight;
          // Account for elevation difference
          const elevationDiff = this.heightOffset;
          const netHead = liquidHeight - elevationDiff;
          pressure = this.fluidDensity * this.gravity * netHead;
          pressure += 101325; // Add atmospheric
          
          // Subtract dynamic losses (simplified)
          const flow = this.flowNetwork.getInputFlow(this.id);
          const velocityHead = 0.5 * this.fluidDensity * Math.pow(flow * 4, 2); // Simplified v¬≤
          pressure -= velocityHead * 0.1; // 10% loss factor
        } else {
          pressure = 101325;
        }
        break;
        
      case 'pump_outlet':
        // Discharge pressure (pump adds energy)
        const pump = this._getPumpFromInputs();
        if (pump && pump.running) {
          // Base pressure from inlet
          const inletPressure = this.calculateInletPressure();
          
          // Add pump head (simplified: 10m head per m¬≥/s capacity)
          const pumpHead = pump.capacity * 10; // meters of head
          const pumpPressure = this.fluidDensity * this.gravity * pumpHead;
          
          pressure = inletPressure + pumpPressure;
        } else {
          pressure = this.calculateInletPressure(); // No boost if pump off
        }
        break;
        
      case 'static':
      default:
        // Simple static pressure at height offset
        pressure = 101325 + (this.fluidDensity * this.gravity * this.heightOffset);
        break;
    }
    
    // Convert to bar (1 bar = 100,000 Pa)
    return pressure / 100000;
  }

  /**
   * Helper: Calculate inlet pressure (used by pump_outlet)
   */
  calculateInletPressure() {
    const tank = this._getTankFromInputs();
    if (tank) {
      const liquidHeight = tank.level * tank.maxHeight;
      return 101325 + (this.fluidDensity * this.gravity * liquidHeight);
    }
    return 101325;
  }

  /**
   * Helper: Get tank from input connections
   */
  _getTankFromInputs() {
    if (!this.flowNetwork) return null;
    
    for (const inputId of this.inputs) {
      const component = this.flowNetwork.getComponent(inputId);
      if (component && component.type === 'tank') {
        return component;
      }
    }
    return null;
  }

  /**
   * Helper: Get pump from input connections
   */
  _getPumpFromInputs() {
    if (!this.flowNetwork) return null;
    
    for (const inputId of this.inputs) {
      const component = this.flowNetwork.getComponent(inputId);
      if (component && component.type === 'pump') {
        return component;
      }
    }
    return null;
  }

  /**
   * Update sensor reading
   */
  update(dt) {
    // Store previous reading
    this.previousPressure = this.pressure;
    
    // Calculate new pressure
    this.pressure = this.calculatePressure();
    
    // Apply accuracy (round to sensor precision)
    this.pressure = Math.round(this.pressure / this.accuracy) * this.accuracy;
    
    // Calculate trend (rate of change)
    this.trend = (this.pressure - this.previousPressure) / dt;
    
    // Check alarms
    this._checkAlarms();
  }

  /**
   * Check if pressure is outside alarm limits
   */
  _checkAlarms() {
    const wasActive = this.alarmActive;
    
    if (this.lowAlarm !== null && this.pressure < this.lowAlarm) {
      this.alarmActive = true;
      if (!wasActive) {
        console.warn(`‚ö†Ô∏è Low pressure alarm: ${this.name} (${this.pressure.toFixed(2)} ${this.units})`);
      }
    } else if (this.highAlarm !== null && this.pressure > this.highAlarm) {
      this.alarmActive = true;
      if (!wasActive) {
        console.warn(`‚ö†Ô∏è High pressure alarm: ${this.name} (${this.pressure.toFixed(2)} ${this.units})`);
      }
    } else {
      if (wasActive) {
        console.log(`‚úÖ Pressure normal: ${this.name}`);
      }
      this.alarmActive = false;
    }
  }

  /**
   * Render visual gauge (if element exists)
   */
  render() {
    if (!this.gaugeElement) return;
    
    // Calculate gauge position (0-100%)
    const [min, max] = this.range;
    const percent = Math.max(0, Math.min(100, 
      ((this.pressure - min) / (max - min)) * 100
    ));
    
    // Update gauge needle or bar
    const needle = this.gaugeElement.querySelector('.gauge-needle');
    if (needle) {
      needle.style.transform = `rotate(${percent * 1.8 - 90}deg)`; // -90¬∞ to 90¬∞
    }
    
    // Update reading text
    const reading = this.gaugeElement.querySelector('.gauge-reading');
    if (reading) {
      reading.textContent = `${this.pressure.toFixed(2)} ${this.units}`;
    }
    
    // Update alarm indicator
    if (this.alarmActive) {
      this.gaugeElement.classList.add('alarm');
    } else {
      this.gaugeElement.classList.remove('alarm');
    }
  }

  /**
   * Get current pressure
   */
  getPressure() {
    return this.pressure;
  }

  /**
   * Get pressure as string with units
   */
  getPressureString() {
    return `${this.pressure.toFixed(2)} ${this.units}`;
  }

  /**
   * Check if pressure is in normal range
   */
  isNormal() {
    return !this.alarmActive;
  }

  /**
   * Get sensor status
   */
  getStatus() {
    if (this.lowAlarm !== null && this.pressure < this.lowAlarm) {
      return 'LOW';
    }
    if (this.highAlarm !== null && this.pressure > this.highAlarm) {
      return 'HIGH';
    }
    return 'NORMAL';
  }

  /**
   * Reset sensor
   */
  reset() {
    super.reset();
    this.pressure = 0;
    this.previousPressure = 0;
    this.trend = 0;
    this.alarmActive = false;
  }

  /**
   * Get sensor info
   */
  getInfo() {
    return {
      ...super.getInfo(),
      pressure: this.getPressureString(),
      trend: this.trend.toFixed(3) + ' bar/s',
      measurementPoint: this.measurementPoint,
      range: `${this.range[0]}-${this.range[1]} ${this.units}`,
      status: this.getStatus(),
      alarm: this.alarmActive
    };
  }
}

// Export
window.PressureSensor = PressureSensor;


/**
 * TankManager.js - Manages all tanks in the system
 * 
 * Creates, configures, and updates all tank components
 */

class TankManager {
  constructor(config, flowNetwork) {
    this.config = config;
    this.flowNetwork = flowNetwork;
    this.tanks = {};
    
    this._initializeTanks();
    this._setupStatusDisplay();
    
    console.log(`TankManager initialized with ${Object.keys(this.tanks).length} tanks`);
  }

  /**
   * Initialize all tanks from config
   */
  _initializeTanks() {
    for (const [key, cfg] of Object.entries(this.config)) {
      const tank = new Tank({
        ...cfg,
        flowNetwork: this.flowNetwork
      });
      
      this.tanks[key] = tank;
      this.flowNetwork.addComponent(tank);
      
      // Setup change callback
      tank.onChange = (t) => this._onTankChange(key, t);
      
      // Initial render
      tank.render();
    }
  }

  /**
   * Setup status display updates
   */
  _setupStatusDisplay() {
    // Update tank status displays every 100ms (10Hz)
    this.statusInterval = setInterval(() => {
      this._updateStatusDisplays();
    }, 100);
  }

  /**
   * Update all status displays
   */
  _updateStatusDisplays() {
    for (const [key, tank] of Object.entries(this.tanks)) {
      // Update any status elements that exist
      const statusEl = document.getElementById(`${tank.id}Status`);
      const levelEl = document.getElementById(`${tank.id}Level`);
      const volumeEl = document.getElementById(`${tank.id}Volume`);
      const flowInEl = document.getElementById(`${tank.id}FlowIn`);
      const flowOutEl = document.getElementById(`${tank.id}FlowOut`);
      
      if (statusEl) {
        statusEl.textContent = tank.isEmpty() ? '‚ö†Ô∏è EMPTY' : 
                               tank.isFull() ? '‚ö†Ô∏è FULL' : 
                               tank.isLow() ? '‚ö†Ô∏è LOW' : 
                               tank.isHigh() ? '‚ö†Ô∏è HIGH' : '‚úÖ OK';
        
        // Color coding
        if (tank.isEmpty() || tank.isFull()) {
          statusEl.style.color = '#ff6b6b';
        } else if (tank.isLow() || tank.isHigh()) {
          statusEl.style.color = '#ffc107';
        } else {
          statusEl.style.color = '#3ddc97';
        }
      }
      
      if (levelEl) {
        levelEl.textContent = tank.getLevelPercent() + '%';
      }
      
      if (volumeEl) {
        volumeEl.textContent = tank.volume.toFixed(3) + ' m¬≥';
      }
      
      if (flowInEl) {
        flowInEl.textContent = tank.lastInputFlow.toFixed(2) + ' m¬≥/s';
      }
      
      if (flowOutEl) {
        flowOutEl.textContent = tank.lastOutputFlow.toFixed(2) + ' m¬≥/s';
      }
    }
  }

  /**
   * Called when tank state changes
   */
  _onTankChange(key, tank) {
    console.log(`Tank ${key} changed:`, tank.getInfo());
  }

  /**
   * Get tank by key
   */
  getTank(key) {
    return this.tanks[key];
  }

  /**
   * Get all tanks
   */
  getAllTanks() {
    return this.tanks;
  }

  /**
   * Set tank level by key
   */
  setTankLevel(key, percent) {
    const tank = this.tanks[key];
    if (!tank) {
      console.warn(`Tank ${key} not found`);
      return;
    }
    
    tank.setLevelPercent(percent);
  }

  /**
   * Check if any tank is overflowing
   */
  hasOverflow() {
    for (const tank of Object.values(this.tanks)) {
      if (tank.isFull()) return true;
    }
    return false;
  }

  /**
   * Check if any tank is empty
   */
  hasEmpty() {
    for (const tank of Object.values(this.tanks)) {
      if (tank.isEmpty()) return true;
    }
    return false;
  }

  /**
   * Get total system volume
   */
  getTotalVolume() {
    let total = 0;
    for (const tank of Object.values(this.tanks)) {
      total += tank.volume;
    }
    return total;
  }

  /**
   * Get total system capacity
   */
  getTotalCapacity() {
    let total = 0;
    for (const tank of Object.values(this.tanks)) {
      total += tank.maxVolume;
    }
    return total;
  }

  /**
   * Get system-wide fill percentage
   */
  getSystemFillPercent() {
    const capacity = this.getTotalCapacity();
    if (capacity === 0) return 0;
    return Math.round((this.getTotalVolume() / capacity) * 100);
  }

  /**
   * Reset all tanks
   */
  reset() {
    for (const tank of Object.values(this.tanks)) {
      tank.reset();
      tank.render();
    }
    console.log('All tanks reset');
  }

  /**
   * Destroy and cleanup
   */
  destroy() {
    // Clear status interval
    if (this.statusInterval) {
      clearInterval(this.statusInterval);
    }
    
    for (const tank of Object.values(this.tanks)) {
      tank.destroy();
    }
    
    this.tanks = {};
  }
}

// Export
window.TankManager = TankManager;


/**
 * PumpManager.js - Manages all pumps in the system
 * 
 * Creates, configures, and controls all pump types with modal interfaces
 */

class PumpManager {
  constructor(config, flowNetwork) {
    this.config = config;
    this.flowNetwork = flowNetwork;
    this.pumps = {};
    this.modals = {};
    
    this._initializePumps();
    this._createModals();
    this._setupEventListeners();
    
    console.log(`PumpManager initialized with ${Object.keys(this.pumps).length} pumps`);
  }

  /**
   * Initialize all pumps from config
   */
  _initializePumps() {
    for (const [key, cfg] of Object.entries(this.config)) {
      let pump;
      
      // Create appropriate pump type
      switch (cfg.pumpType) {
        case 'fixed':
          pump = new FixedSpeedPump(cfg);
          break;
        case 'variable':
          pump = new VariableSpeedPump(cfg);
          break;
        case '3-speed':
          pump = new ThreeSpeedPump(cfg);
          break;
        default:
          console.warn(`Unknown pump type: ${cfg.pumpType}, defaulting to fixed`);
          pump = new FixedSpeedPump(cfg);
      }
      
      this.pumps[key] = pump;
      this.flowNetwork.addComponent(pump);
      
      // Setup change callback
      pump.onChange = (p) => this._onPumpChange(key, p);
    }
  }

  /**
   * Create modal for each pump
   */
  _createModals() {
    for (const [key, pump] of Object.entries(this.pumps)) {
      const modal = this._createModalElement(key, pump);
      document.body.appendChild(modal);
      this.modals[key] = modal;
    }
  }

  /**
   * Create modal HTML for a pump
   */
  _createModalElement(key, pump) {
    const overlay = document.createElement('div');
    overlay.id = `${pump.id}Modal`;
    overlay.className = 'valve-modal-overlay'; // Reuse valve modal styles
    overlay.setAttribute('aria-hidden', 'true');
    
    const title = pump.config?.modalTitle || `${pump.name} Control`;
    
    // Create modal content based on pump type
    let controlsHTML = '';
    
    if (pump.pumpType === 'fixed') {
      controlsHTML = `
        <div class="pump-controls">
          <button type="button" class="btn toggle pump-toggle" data-pump="${key}" aria-pressed="false">
            Start Pump
          </button>
          <div class="pump-status">
            <div class="kv">
              <div>Status</div><div class="pump-status-text">OFF</div>
              <div>Flow Rate</div><div class="pump-flow">0.00 m¬≥/s</div>
              <div>Run Time</div><div class="pump-runtime">0s</div>
            </div>
          </div>
        </div>
      `;
    } else if (pump.pumpType === 'variable') {
      controlsHTML = `
        <div class="pump-controls">
          <div class="row">
            <button type="button" class="btn pump-stop" data-pump="${key}">Stop</button>
            <button type="button" class="btn toggle pump-toggle" data-pump="${key}" aria-pressed="false">
              Start
            </button>
          </div>
          <div class="row" style="margin-top: 16px;">
            <label for="${pump.id}Speed">Speed</label>
            <input type="range" id="${pump.id}Speed" class="grow pump-speed-slider" 
                   data-pump="${key}" min="0" max="100" step="1" value="0"/>
            <output class="pump-speed-output">0%</output>
          </div>
          <div class="pump-status">
            <div class="kv">
              <div>Status</div><div class="pump-status-text">OFF</div>
              <div>Flow Rate</div><div class="pump-flow">0.00 m¬≥/s</div>
              <div>Run Time</div><div class="pump-runtime">0s</div>
            </div>
          </div>
        </div>
      `;
    } else if (pump.pumpType === '3-speed') {
      controlsHTML = `
        <div class="pump-controls">
          <div class="row">
            <button type="button" class="btn pump-stop" data-pump="${key}">Stop</button>
          </div>
          <div class="row" style="margin-top: 12px; gap: 8px;">
            <button type="button" class="btn pump-speed-btn" data-pump="${key}" data-speed="0">Low</button>
            <button type="button" class="btn pump-speed-btn" data-pump="${key}" data-speed="1">Medium</button>
            <button type="button" class="btn pump-speed-btn" data-pump="${key}" data-speed="2">High</button>
          </div>
          <div class="pump-status">
            <div class="kv">
              <div>Status</div><div class="pump-status-text">OFF</div>
              <div>Speed</div><div class="pump-speed-setting">-</div>
              <div>Flow Rate</div><div class="pump-flow">0.00 m¬≥/s</div>
              <div>Run Time</div><div class="pump-runtime">0s</div>
            </div>
          </div>
        </div>
      `;
    }
    
    // Add cavitation warning if enabled
    if (pump.cavitation.enabled) {
      controlsHTML += `
        <div class="pump-cavitation-warning" style="display: none; margin-top: 16px; padding: 12px; background: rgba(255, 107, 107, 0.1); border: 1px solid #ff6b6b; border-radius: 8px; color: #ff6b6b;">
          ‚ö†Ô∏è <strong>CAVITATION DETECTED</strong><br>
          <small>Flow reduced - Check suction conditions</small>
        </div>
      `;
    }
    
    overlay.innerHTML = `
      <div class="valve-modal-container">
        <button type="button" aria-label="Close ${title}" class="valve-modal-close pump-modal-close" data-pump="${key}">√ó</button>
        <div class="valve-modal-title">${title}</div>
        <div style="padding: 20px;">
          ${controlsHTML}
        </div>
      </div>
    `;
    
    return overlay;
  }

  /**
   * Setup event listeners for all pumps and modals
   */
  _setupEventListeners() {
    for (const [key, pump] of Object.entries(this.pumps)) {
      const svgElement = document.querySelector(pump.svgElement);
      const modal = this.modals[key];
      
      if (!svgElement) {
        console.warn(`SVG element ${pump.svgElement} not found for pump ${key}`);
        continue;
      }
      
      // Click pump to open modal
      svgElement.addEventListener('click', () => this.openModal(key));
      svgElement.addEventListener('keydown', (e) => {
        if (e.key === ' ' || e.key === 'Enter') {
          e.preventDefault();
          this.openModal(key);
        }
      });
      
      // Close button
      const closeBtn = modal.querySelector('.pump-modal-close');
      closeBtn?.addEventListener('click', () => this.closeModal(key));
      
      // Click outside to close
      modal.addEventListener('click', (e) => {
        if (e.target === modal) this.closeModal(key);
      });
      
      // Setup pump-specific controls
      this._setupPumpControls(key, pump, modal);
    }
    
    // Global escape key handler
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        for (const key of Object.keys(this.modals)) {
          if (this.modals[key].classList.contains('open')) {
            this.closeModal(key);
          }
        }
      }
    });
  }

  /**
   * Setup pump-specific controls in modal
   */
  _setupPumpControls(key, pump, modal) {
    if (pump.pumpType === 'fixed') {
      // Fixed speed: toggle button
      const toggle = modal.querySelector('.pump-toggle');
      toggle?.addEventListener('click', () => {
        pump.toggle();
        this._updateModalUI(key);
      });
      
    } else if (pump.pumpType === 'variable') {
      // Variable speed: start, stop, slider
      const startBtn = modal.querySelector('.pump-toggle');
      const stopBtn = modal.querySelector('.pump-stop');
      const slider = modal.querySelector('.pump-speed-slider');
      const output = modal.querySelector('.pump-speed-output');
      
      startBtn?.addEventListener('click', () => {
        pump.start();
        this._updateModalUI(key);
      });
      
      stopBtn?.addEventListener('click', () => {
        pump.stop();
        this._updateModalUI(key);
      });
      
      slider?.addEventListener('input', (e) => {
        const speed = parseInt(e.target.value) / 100;
        pump.setSpeed(speed);
        if (output) output.textContent = e.target.value + '%';
        this._updateModalUI(key);
      });
      
    } else if (pump.pumpType === '3-speed') {
      // 3-speed: stop button + speed buttons
      const stopBtn = modal.querySelector('.pump-stop');
      const speedBtns = modal.querySelectorAll('.pump-speed-btn');
      
      stopBtn?.addEventListener('click', () => {
        pump.stop();
        this._updateModalUI(key);
      });
      
      speedBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          const speedIndex = parseInt(btn.dataset.speed);
          pump.setSpeedIndex(speedIndex);
          this._updateModalUI(key);
        });
      });
    }
  }

  /**
   * Open pump modal
   */
  openModal(key) {
    const modal = this.modals[key];
    if (!modal) return;
    
    modal.classList.add('open');
    modal.setAttribute('aria-hidden', 'false');
    document.body.style.overflow = 'hidden';
    
    this._updateModalUI(key);
    
    console.log(`Opened ${this.pumps[key].name} modal`);
  }

  /**
   * Close pump modal
   */
  closeModal(key) {
    const modal = this.modals[key];
    if (!modal) return;
    
    modal.classList.remove('open');
    modal.setAttribute('aria-hidden', 'true');
    document.body.style.overflow = '';
  }

  /**
   * Update modal UI to reflect pump state
   */
  _updateModalUI(key) {
    const pump = this.pumps[key];
    const modal = this.modals[key];
    if (!modal) return;
    
    // Update status text
    const statusText = modal.querySelector('.pump-status-text');
    if (statusText) {
      statusText.textContent = pump.running ? 'RUNNING' : 'OFF';
      statusText.style.color = pump.running ? '#3ddc97' : '#9bb0ff';
    }
    
    // Update flow rate
    const flowText = modal.querySelector('.pump-flow');
    if (flowText) {
      flowText.textContent = pump.getOutputFlow().toFixed(2) + ' m¬≥/s';
    }
    
    // Update runtime
    const runtimeText = modal.querySelector('.pump-runtime');
    if (runtimeText) {
      runtimeText.textContent = Math.floor(pump.runTime) + 's';
    }
    
    // Update pump-type-specific UI
    if (pump.pumpType === 'fixed') {
      const toggle = modal.querySelector('.pump-toggle');
      if (toggle) {
        toggle.setAttribute('aria-pressed', pump.running);
        toggle.textContent = pump.running ? 'Stop Pump' : 'Start Pump';
      }
      
    } else if (pump.pumpType === 'variable') {
      const slider = modal.querySelector('.pump-speed-slider');
      const output = modal.querySelector('.pump-speed-output');
      if (slider && output) {
        const speedPercent = pump.getSpeedPercent();
        slider.value = speedPercent;
        output.textContent = speedPercent + '%';
      }
      
    } else if (pump.pumpType === '3-speed') {
      const speedSetting = modal.querySelector('.pump-speed-setting');
      if (speedSetting) {
        speedSetting.textContent = pump.running ? pump.getSpeedName() : '-';
      }
      
      // Highlight active speed button
      const speedBtns = modal.querySelectorAll('.pump-speed-btn');
      speedBtns.forEach((btn, index) => {
        if (index === pump.getSpeedIndex() && pump.running) {
          btn.classList.add('toggle');
          btn.setAttribute('aria-pressed', 'true');
        } else {
          btn.classList.remove('toggle');
          btn.setAttribute('aria-pressed', 'false');
        }
      });
    }
    
    // Update cavitation warning
    const cavWarning = modal.querySelector('.pump-cavitation-warning');
    if (cavWarning) {
      cavWarning.style.display = pump.cavitation.active ? 'block' : 'none';
    }
  }

  /**
   * Called when pump changes
   */
  _onPumpChange(key, pump) {
    // Update modal if open
    if (this.modals[key]?.classList.contains('open')) {
      this._updateModalUI(key);
    }
    
    // Update SVG element state
    const svgElement = document.querySelector(pump.svgElement);
    if (svgElement) {
      svgElement.setAttribute('aria-pressed', pump.running);
    }
    
    console.log(`Pump ${key} changed:`, pump.getInfo());
  }

  /**
   * Get pump by key
   */
  getPump(key) {
    return this.pumps[key];
  }

  /**
   * Get all pumps
   */
  getAllPumps() {
    return this.pumps;
  }

  /**
   * Reset all pumps
   */
  reset() {
    for (const pump of Object.values(this.pumps)) {
      pump.reset();
    }
  }

  /**
   * Destroy and cleanup
   */
  destroy() {
    for (const pump of Object.values(this.pumps)) {
      pump.destroy();
    }
    
    for (const modal of Object.values(this.modals)) {
      modal.remove();
    }
    
    this.pumps = {};
    this.modals = {};
  }
}

// Export
window.PumpManager = PumpManager;


/**
 * ValveManager.js - Manages all valves with interactive wheel controls
 * 
 * Creates modals with iframe valve controls for each valve
 */

class ValveManager {
  constructor(config, flowNetwork) {
    this.config = config;
    this.flowNetwork = flowNetwork;
    this.valves = {};
    this.modals = {};
    this.iframes = {};
    
    this._initializeValves();
    this._createModals();
    this._setupEventListeners();
    this._setupPostMessageListener();
    
    console.log(`ValveManager initialized with ${Object.keys(this.valves).length} valves`);
  }

  /**
   * Initialize all valves from config
   */
  _initializeValves() {
  for (const [key, cfg] of Object.entries(this.config)) {
    const valve = new Valve({
      ...cfg,
      flowNetwork: this.flowNetwork  // ‚úÖ ADD THIS
    });
    this.valves[key] = valve;
    this.flowNetwork.addComponent(valve);
    
    valve.onChange = (v) => this._onValveChange(key, v);
  }
}

  /**
   * Create modal for each valve with iframe
   */
  _createModals() {
    for (const [key, valve] of Object.entries(this.valves)) {
      const modal = this._createModalElement(key, valve);
      document.body.appendChild(modal);
      this.modals[key] = modal;
      this.iframes[key] = modal.querySelector('iframe');
      
      // Setup iframe communication after it loads
      this._setupIframeSync(key, this.iframes[key]);
    }
  }

  /**
   * Create modal HTML with iframe for a valve
   */
  _createModalElement(key, valve) {
    const overlay = document.createElement('div');
    overlay.id = `${valve.id}Modal`;
    overlay.className = 'valve-modal-overlay';
    overlay.setAttribute('aria-hidden', 'true');
    
    const title = valve.config?.modalTitle || `${valve.name} Control`;
    const iframeUrl = valve.config?.iframeUrl || 'valve.html';
    
    overlay.innerHTML = `
      <div class="valve-modal-container">
        <button type="button" aria-label="Close ${title}" class="valve-modal-close valve-close-btn" data-valve="${key}">√ó</button>
        <div class="valve-modal-title">${title}</div>
        <iframe src="${iframeUrl}" title="${title}" class="valve-iframe"></iframe>
      </div>
    `;
    
    return overlay;
  }

  /**
   * Setup iframe communication for a valve
   */
  _setupIframeSync(key, iframe) {
    if (!iframe) return;
    
    iframe.addEventListener('load', () => {
      console.log(`Valve iframe loaded: ${key}`);
      
      // Wait for ValveTop to initialize
      setTimeout(() => {
        const valve = this.valves[key];
        
        // Set initial position
        this._sendValvePosition(iframe, valve.position);
        
        // Setup onChange callback (direct API - works on web server)
        try {
          if (iframe.contentWindow && iframe.contentWindow.ValveTop) {
            iframe.contentWindow.ValveTop.onChange((pos) => {
              this._onIframePositionChange(key, pos);
            });
            console.log(`‚úÖ Valve ${key} direct onChange callback set`);
          }
        } catch(e) {
          console.warn(`‚ö†Ô∏è Direct callback failed for valve ${key}, using postMessage fallback`);
        }
      }, 150);
    });
  }

  /**
   * Setup global postMessage listener (fallback for file:// protocol)
   */
  _setupPostMessageListener() {
    window.addEventListener('message', (event) => {
      // Check if message is from a valve iframe
      if (event.data && event.data.type === 'valve:changed') {
        // Find which valve sent this message
        for (const [key, iframe] of Object.entries(this.iframes)) {
          if (event.source === iframe.contentWindow) {
            const position = Math.max(0, Math.min(1, parseFloat(event.data.value) || 0));
            this._onIframePositionChange(key, position);
            console.log(`üì® Valve ${key} updated via postMessage: ${(position * 100).toFixed(0)}%`);
            break;
          }
        }
      }
    });
    console.log('‚úÖ PostMessage listener active for valve updates');
  }

  /**
   * Send position to iframe valve control
   */
  _sendValvePosition(iframe, position) {
    if (!iframe || !iframe.contentWindow) return;
    
    try {
      // Try direct API call
      if (iframe.contentWindow.ValveTop && 
          typeof iframe.contentWindow.ValveTop.set === 'function') {
        iframe.contentWindow.ValveTop.set(position);
        return;
      }
    } catch(e) {
      // Cross-origin or not loaded yet
    }
    
    // Fallback: postMessage
    try {
      iframe.contentWindow.postMessage({
        type: 'valve:set',
        value: position
      }, '*');
    } catch(e) {
      console.warn('Failed to send valve position:', e);
    }
  }

  /**
   * Called when iframe valve position changes
   */
  _onIframePositionChange(key, position) {
    const valve = this.valves[key];
    if (!valve) return;
    
    valve.setPosition(position);
    console.log(`Valve ${key} set to ${(position * 100).toFixed(0)}%`);
  }

  /**
   * Setup event listeners for all valves
   */
  _setupEventListeners() {
    for (const [key, valve] of Object.entries(this.valves)) {
      const svgElement = document.querySelector(valve.svgElement);
      const modal = this.modals[key];
      
      if (!svgElement) {
        console.warn(`SVG element ${valve.svgElement} not found for valve ${key}`);
        continue;
      }
      
      // Click valve to open modal
      svgElement.addEventListener('click', () => this.openModal(key));
      svgElement.addEventListener('keydown', (e) => {
        if (e.key === ' ' || e.key === 'Enter') {
          e.preventDefault();
          this.openModal(key);
        }
      });
      
      // Close button
      const closeBtn = modal.querySelector('.valve-close-btn');
      closeBtn?.addEventListener('click', () => this.closeModal(key));
      
      // Click outside to close
      modal.addEventListener('click', (e) => {
        if (e.target === modal) this.closeModal(key);
      });
    }
    
    // Global escape key handler
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        for (const key of Object.keys(this.modals)) {
          if (this.modals[key].classList.contains('open')) {
            this.closeModal(key);
          }
        }
      }
    });
  }

  /**
   * Open valve modal
   */
  openModal(key) {
    const modal = this.modals[key];
    const valve = this.valves[key];
    
    if (!modal || !valve) return;
    
    modal.classList.add('open');
    modal.setAttribute('aria-hidden', 'false');
    document.body.style.overflow = 'hidden';
    
    // Send current position to iframe
    setTimeout(() => {
      this._sendValvePosition(this.iframes[key], valve.position);
    }, 100);
    
    console.log(`Opened ${valve.name} modal at ${valve.getPositionPercent()}%`);
  }

  /**
   * Close valve modal
   */
  closeModal(key) {
    const modal = this.modals[key];
    if (!modal) return;
    
    modal.classList.remove('open');
    modal.setAttribute('aria-hidden', 'true');
    document.body.style.overflow = '';
  }

  /**
   * Called when valve changes
   * REALISTIC FIELD OPERATION: No visual hints - user must click to check position
   */
  _onValveChange(key, valve) {
    // Update ARIA state for accessibility
    const svgElement = document.querySelector(valve.svgElement);
    if (svgElement) {
      svgElement.setAttribute('aria-pressed', valve.isOpen());
      
      // REMOVED: No opacity changes
      // Valves always look the same regardless of position
      // User must click to check - just like in the field!
    }
    
    console.log(`Valve ${key} changed:`, valve.getInfo());
  }

  /**
   * Get valve by key
   */
  getValve(key) {
    return this.valves[key];
  }

  /**
   * Get all valves
   */
  getAllValves() {
    return this.valves;
  }

  /**
   * Set valve position
   */
  setValvePosition(key, position) {
    const valve = this.valves[key];
    if (!valve) return;
    
    valve.setPosition(position);
    
    // Update iframe if modal is open
    if (this.modals[key]?.classList.contains('open')) {
      this._sendValvePosition(this.iframes[key], position);
    }
  }

  /**
   * Reset all valves
   */
  reset() {
    for (const valve of Object.values(this.valves)) {
      valve.reset();
    }
  }

  /**
   * Destroy and cleanup
   */
  destroy() {
    for (const valve of Object.values(this.valves)) {
      valve.destroy();
    }
    
    for (const modal of Object.values(this.modals)) {
      modal.remove();
    }
    
    this.valves = {};
    this.modals = {};
    this.iframes = {};
  }
}

// Export
window.ValveManager = ValveManager;


/**
 * PipeManager.js - Manages all pipes and flow animations
 * 
 * Controls flow visualization throughout the system
 */

class PipeManager {
  constructor(config, flowNetwork) {
    this.config = config;
    this.flowNetwork = flowNetwork;
    this.pipes = {};
    
    this._initializePipes();
    this._setupFlowMonitoring();
    
    console.log(`PipeManager initialized with ${Object.keys(this.pipes).length} pipes`);
  }

  /**
   * Initialize all pipes from config
   */
  _initializePipes() {
    for (const [key, cfg] of Object.entries(this.config)) {
      const pipe = new Pipe({
        ...cfg,
        flowNetwork: this.flowNetwork
      });
      
      this.pipes[key] = pipe;
      this.flowNetwork.addComponent(pipe);
      
      // Setup change callback
      pipe.onChange = (p) => this._onPipeChange(key, p);
    }
  }

  /**
   * Setup flow monitoring for debug
   */
  _setupFlowMonitoring() {
    // Optional: log significant flow changes
    this.lastLogTime = performance.now();
    this.logInterval = 5000; // Log every 5 seconds
  }

  /**
   * Called when pipe state changes
   */
  _onPipeChange(key, pipe) {
    // Optional: log flow changes
    const now = performance.now();
    if (now - this.lastLogTime > this.logInterval) {
      if (pipe.flowRate > 0.001) {
        console.log(`Pipe ${key}: ${pipe.flowRate.toFixed(2)} m¬≥/s (${pipe.getFlowRegime()})`);
      }
      this.lastLogTime = now;
    }
  }

  /**
   * Get pipe by key
   */
  getPipe(key) {
    return this.pipes[key];
  }

  /**
   * Get all pipes
   */
  getAllPipes() {
    return this.pipes;
  }

  /**
   * Get all active flows (pipes with flow > 0)
   */
  getActiveFlows() {
    const active = [];
    for (const [key, pipe] of Object.entries(this.pipes)) {
      if (pipe.flowRate > 0.001) {
        active.push({
          pipe: key,
          name: pipe.name,
          flowRate: pipe.flowRate,
          velocity: pipe.velocity
        });
      }
    }
    return active;
  }

  /**
   * Get total system flow rate
   */
  getTotalFlow() {
    let total = 0;
    for (const pipe of Object.values(this.pipes)) {
      total += pipe.flowRate;
    }
    return total;
  }

  /**
   * Get highest flow rate
   */
  getMaxFlow() {
    let max = 0;
    for (const pipe of Object.values(this.pipes)) {
      if (pipe.flowRate > max) max = pipe.flowRate;
    }
    return max;
  }

  /**
   * Check if any pipe is flowing
   */
  hasActiveFlow() {
    for (const pipe of Object.values(this.pipes)) {
      if (pipe.flowRate > 0.001) return true;
    }
    return false;
  }

  /**
   * Get flow path from component A to component B
   */
  getFlowPath(fromId, toId) {
    const path = [];
    for (const [key, pipe] of Object.entries(this.pipes)) {
      if (pipe.inputs.includes(fromId) && pipe.outputs.includes(toId)) {
        path.push(key);
      }
    }
    return path;
  }

  /**
   * Enable/disable all flow animations
   */
  setAnimationsEnabled(enabled) {
    for (const pipe of Object.values(this.pipes)) {
      if (enabled) {
        pipe.render();
      } else {
        if (pipe.flowPath) {
          pipe.flowPath.classList.remove('on');
        }
      }
    }
  }

  /**
   * Set global animation speed multiplier
   */
  setGlobalAnimationSpeed(speed) {
    for (const pipe of Object.values(this.pipes)) {
      pipe.animationSpeed = speed;
    }
  }

  /**
   * Reset all pipes
   */
  reset() {
    for (const pipe of Object.values(this.pipes)) {
      pipe.reset();
    }
    console.log('All pipes reset');
  }

  /**
   * Destroy and cleanup
   */
  destroy() {
    for (const pipe of Object.values(this.pipes)) {
      pipe.destroy();
    }
    
    this.pipes = {};
  }
}

// Export
window.PipeManager = PipeManager;


/**
 * PressureManager.js - Manages all pressure sensors
 * 
 * Creates, updates, and displays pressure readings
 */

class PressureManager {
  constructor(config, flowNetwork) {
    this.config = config;
    this.flowNetwork = flowNetwork;
    this.sensors = {};
    
    this._initializeSensors();
    this._setupStatusDisplay();
    
    console.log(`PressureManager initialized with ${Object.keys(this.sensors).length} sensors`);
  }

  /**
   * Initialize all sensors from config
   */
  _initializeSensors() {
    for (const [key, cfg] of Object.entries(this.config)) {
      const sensor = new PressureSensor({
        ...cfg,
        flowNetwork: this.flowNetwork
      });
      
      this.sensors[key] = sensor;
      this.flowNetwork.addComponent(sensor);
      
      // Setup change callback
      sensor.onChange = (s) => this._onSensorChange(key, s);
    }
  }

  /**
   * Setup status display updates
   */
  _setupStatusDisplay() {
    // Update sensor displays every 100ms (10Hz)
    this.statusInterval = setInterval(() => {
      this._updateStatusDisplays();
    }, 100);
  }

  /**
   * Update all status displays
   */
  _updateStatusDisplays() {
    for (const [key, sensor] of Object.entries(this.sensors)) {
      // Update any status elements that exist
      const pressureEl = document.getElementById(`${sensor.id}Pressure`);
      const statusEl = document.getElementById(`${sensor.id}Status`);
      const trendEl = document.getElementById(`${sensor.id}Trend`);
      
      if (pressureEl) {
        pressureEl.textContent = sensor.getPressureString();
      }
      
      if (statusEl) {
        const status = sensor.getStatus();
        statusEl.textContent = status === 'NORMAL' ? '‚úÖ OK' : 
                               status === 'LOW' ? '‚ö†Ô∏è LOW' : 
                               '‚ö†Ô∏è HIGH';
        
        // Color coding
        if (status === 'NORMAL') {
          statusEl.style.color = '#3ddc97';
        } else {
          statusEl.style.color = '#ff6b6b';
        }
      }
      
      if (trendEl) {
        const trend = sensor.trend;
        const arrow = trend > 0.01 ? '‚Üë' : trend < -0.01 ? '‚Üì' : '‚Üí';
        trendEl.textContent = arrow;
        trendEl.style.color = trend > 0 ? '#3ddc97' : trend < 0 ? '#ff6b6b' : '#9bb0ff';
      }
    }
  }

  /**
   * Called when sensor reading changes
   */
  _onSensorChange(key, sensor) {
    // Optional: log significant changes
    if (Math.abs(sensor.trend) > 0.1) {
      console.log(`Pressure ${key}: ${sensor.getPressureString()} (${sensor.trend > 0 ? '‚Üë' : '‚Üì'})`);
    }
  }

  /**
   * Get sensor by key
   */
  getSensor(key) {
    return this.sensors[key];
  }

  /**
   * Get all sensors
   */
  getAllSensors() {
    return this.sensors;
  }

  /**
   * Get all pressure readings
   */
  getAllReadings() {
    const readings = {};
    for (const [key, sensor] of Object.entries(this.sensors)) {
      readings[key] = {
        pressure: sensor.pressure,
        units: sensor.units,
        status: sensor.getStatus(),
        alarm: sensor.alarmActive
      };
    }
    return readings;
  }

  /**
   * Check if any sensor has active alarm
   */
  hasActiveAlarms() {
    for (const sensor of Object.values(this.sensors)) {
      if (sensor.alarmActive) return true;
    }
    return false;
  }

  /**
   * Get list of active alarms
   */
  getActiveAlarms() {
    const alarms = [];
    for (const [key, sensor] of Object.entries(this.sensors)) {
      if (sensor.alarmActive) {
        alarms.push({
          sensor: key,
          name: sensor.name,
          pressure: sensor.getPressureString(),
          status: sensor.getStatus()
        });
      }
    }
    return alarms;
  }

  /**
   * Get highest pressure reading
   */
  getMaxPressure() {
    let max = 0;
    for (const sensor of Object.values(this.sensors)) {
      if (sensor.pressure > max) max = sensor.pressure;
    }
    return max;
  }

  /**
   * Get lowest pressure reading
   */
  getMinPressure() {
    let min = Infinity;
    for (const sensor of Object.values(this.sensors)) {
      if (sensor.pressure < min) min = sensor.pressure;
    }
    return min === Infinity ? 0 : min;
  }

  /**
   * Reset all sensors
   */
  reset() {
    for (const sensor of Object.values(this.sensors)) {
      sensor.reset();
    }
    console.log('All pressure sensors reset');
  }

  /**
   * Destroy and cleanup
   */
  destroy() {
    // Clear status interval
    if (this.statusInterval) {
      clearInterval(this.statusInterval);
    }
    
    for (const sensor of Object.values(this.sensors)) {
      sensor.destroy();
    }
    
    this.sensors = {};
  }
}

// Export
window.PressureManager = PressureManager;


/**
 * systemConfig.js - System configuration with component-only topology
 * 
 * Flow path: feed1 ‚Üí inletValve ‚Üí tank1 ‚Üí pump1 ‚Üí outletValve ‚Üí drain
 * Pipes are visual only and read flows from the network
 */

const SYSTEM_CONFIG = {
  
  // ============================================================================
  // BOUNDARY CONDITIONS (New!)
  // ============================================================================
  feeds: {
    mainFeed: {
      id: 'feed1',
      name: 'Main Water Supply',
      type: 'feed',
      
      // Boundary properties
      supplyPressure: 3.0,    // bar (typical municipal water)
      maxFlow: Infinity,      // Unlimited supply
      temperature: 20,        // ¬∞C
      available: true,        // Supply available
      
      // Connections (no inputs, outputs to first valve)
      inputs: [],
      outputs: ['inletValve']
    }
  },
  
  drains: {
    mainDrain: {
      id: 'drain',
      name: 'System Discharge',
      type: 'drain',
      
      // Boundary properties
      ambientPressure: 1.0,   // bar (atmospheric)
      maxCapacity: Infinity,  // Unlimited discharge
      backpressure: 0,        // No resistance
      open: true,             // Drain open
      
      // Connections (inputs from last valve, no outputs)
      inputs: ['outletValve'],
      outputs: []
    }
  },
  
  // ============================================================================
  // VALVES
  // ============================================================================
  valves: {
    inlet: {
      id: 'inletValve',
      name: 'Inlet Valve',
      type: 'valve',
      
      // Physical properties
      maxFlow: 0.3,
      
      // Operating parameters
      initialPosition: 0,
      responseTime: 0.1,
      
      // Visual properties
      svgElement: '#valve',
      position: [230, 53],
      
      // Connections (component to component)
      inputs: ['feed1'],      // ‚Üê From feed
      outputs: ['tank1'],     // ‚Üê To tank
      
      // UI
      modalTitle: 'Inlet Valve Control',
      iframeUrl: 'valve.html'
    },
    
    outlet: {
      id: 'outletValve',
      name: 'Outlet Valve',
      type: 'valve',
      
      maxFlow: 0.6,
      initialPosition: 1.0,
      responseTime: 0.1,
      
      svgElement: '#outletValve',
      position: [890, 278],
      
      // Connections (component to component)
      inputs: ['pump1'],      // ‚Üê From pump
      outputs: ['drain'],     // ‚Üê To drain
      
      modalTitle: 'Outlet Valve Control',
      iframeUrl: 'valve.html'
    }
  },
  
  // ============================================================================
  // TANKS
  // ============================================================================
  tanks: {
    mainTank: {
      id: 'tank1',
      name: 'Main Storage Tank',
      type: 'tank',
      
      // Physical properties
      area: 2.5,              // m¬≤ (cross-sectional area)
      maxHeight: 1.2,         // m (height)
      // maxVolume = 2.5 √ó 1.2 = 3.0 m¬≥
      
      // Initial conditions
      initialVolume: 0,       // Start empty
      
      // Visual properties
      svgElement: '#tank',
      position: [340, 120],
      levelRectHeight: 360,   // px
      levelRectY: 360,        // px
      
      // Thresholds
      lowThreshold: 0.1,      // 10% = low alarm
      highThreshold: 0.9,     // 90% = high alarm
      
      // Connections (component to component)
      inputs: ['inletValve'], // ‚Üê From inlet valve
      outputs: ['pump1']      // ‚Üê To pump
    }
  },
  
  // ============================================================================
  // PUMPS
  // ============================================================================
  pumps: {
    mainPump: {
      id: 'pump1',
      name: 'Main Centrifugal Pump',
      type: 'pump',
      pumpType: 'fixed',
      
      // Physical properties
      capacity: 0.5,          // m¬≥/s (max flow rate)
      efficiency: 0.95,       // 95% efficient
      power: 5.5,             // kW
      
      // Operating parameters
      initialSpeed: 0,        // Start OFF
      requiresMinLevel: 0,    // No minimum level required
      
      // Cavitation (disabled for now)
      cavitation: {
        enabled: false,
        triggerTime: 60,
        duration: 5,
        flowReduction: 0.3
      },
      
      // Visual properties
      svgElement: '#pump',
      position: [790, 460],
      
      // Connections (component to component)
      inputs: ['tank1'],      // ‚Üê From tank
      outputs: ['outletValve'], // ‚Üê To outlet valve
      
      // UI
      modalTitle: 'Main Pump Control'
    }
  },
  
  // ============================================================================
  // PIPES (Visual Only - No Flow Routing)
  // ============================================================================
  pipes: {
    sourceToInlet: {
      id: 'pipe1',
      name: 'Source to Inlet Valve',
      type: 'pipe',
      
      diameter: 0.05,         // 50mm
      length: 0.5,            // 0.5m
      
      svgElement: '#pipe1Flow',
      
      // Visual connections (reads flow from feed1‚ÜíinletValve)
      inputs: ['feed1'],
      outputs: ['inletValve']
    },
    
    inletToTank: {
      id: 'pipe2',
      name: 'Inlet Valve to Tank',
      type: 'pipe',
      
      diameter: 0.05,
      length: 1.0,
      
      svgElement: '#pipe2Flow',
      
      // Visual connections (reads flow from inletValve‚Üítank1)
      inputs: ['inletValve'],
      outputs: ['tank1']
    },
    
    tankToPump: {
      id: 'pipe3',
      name: 'Tank to Pump',
      type: 'pipe',
      
      diameter: 0.05,
      length: 0.5,
      
      svgElement: '#pipe3Flow',
      
      // Visual connections (reads flow from tank1‚Üípump1)
      inputs: ['tank1'],
      outputs: ['pump1']
    },
    
    pumpToOutlet: {
      id: 'pipe4',
      name: 'Pump to Outlet Valve',
      type: 'pipe',
      
      diameter: 0.05,
      length: 1.5,
      
      svgElement: '#pipe4Flow',
      
      // Visual connections (reads flow from pump1‚ÜíoutletValve)
      inputs: ['pump1'],
      outputs: ['outletValve']
    },
    
    outletToDrain: {
      id: 'pipe5',
      name: 'Outlet Valve to Drain',
      type: 'pipe',
      
      diameter: 0.05,
      length: 0.5,
      
      svgElement: '#pipe5Flow',
      
      // Visual connections (reads flow from outletValve‚Üídrain)
      inputs: ['outletValve'],
      outputs: ['drain']
    }
  },
  
  // ============================================================================
  // PRESSURE SENSORS
  // ============================================================================
  pressureSensors: {
    tankBottom: {
      id: 'p1',
      name: 'Tank Bottom Pressure',
      type: 'sensor',
      
      measurementPoint: 'tank_bottom',
      range: [0, 2],          // 0-2 bar
      alarmLow: 0.5,          // Low pressure alarm
      alarmHigh: 1.8,         // High pressure alarm
      
      svgElement: null,       // Non-visual for now
      
      inputs: ['tank1'],
      outputs: []
    },
    
    pumpInlet: {
      id: 'p2',
      name: 'Pump Suction Pressure',
      type: 'sensor',
      
      measurementPoint: 'pump_inlet',
      range: [0, 2],
      alarmLow: 0.3,          // Cavitation risk
      alarmHigh: 1.8,
      
      svgElement: null,
      
      inputs: ['tank1'],
      outputs: []
    },
    
    pumpOutlet: {
      id: 'p3',
      name: 'Pump Discharge Pressure',
      type: 'sensor',
      
      measurementPoint: 'pump_outlet',
      range: [0, 15],         // Higher range for discharge
      alarmLow: 0.5,
      alarmHigh: 12,          // Overpressure protection
      
      svgElement: null,
      
      inputs: ['pump1'],
      outputs: []
    },
    
    systemOutlet: {
      id: 'p4',
      name: 'System Outlet Pressure',
      type: 'sensor',
      
      measurementPoint: 'static',
      range: [0, 10],
      alarmLow: 0.8,
      alarmHigh: 8,
      
      svgElement: null,
      
      inputs: ['outletValve'],
      outputs: []
    }
  },
  
  // ============================================================================
  // COMPONENT TEMPLATES (for easy expansion)
  // ============================================================================
  templates: {
    pump: {
      fixed: { 
        pumpType: 'fixed', 
        capacity: 1.0, 
        efficiency: 0.95 
      },
      variable: { 
        pumpType: 'variable', 
        capacity: 1.0, 
        minSpeed: 0.1 
      },
      threeSpeed: { 
        pumpType: '3-speed', 
        speeds: [0.3, 0.6, 1.0] 
      }
    },
    valve: {
      standard: { 
        maxFlow: 0.5, 
        responseTime: 0.1 
      },
      slowActing: { 
        maxFlow: 0.5, 
        responseTime: 0.5 
      },
      quickActing: { 
        maxFlow: 0.5, 
        responseTime: 0.05 
      }
    },
    tank: {
      small: { 
        area: 1.0, 
        maxHeight: 1.0 
      },
      medium: { 
        area: 2.0, 
        maxHeight: 1.5 
      },
      large: { 
        area: 3.0, 
        maxHeight: 2.0 
      }
    },
    feed: {
      lowPressure: { 
        supplyPressure: 2.0, 
        maxFlow: Infinity 
      },
      highPressure: { 
        supplyPressure: 5.0, 
        maxFlow: Infinity 
      },
      limited: { 
        supplyPressure: 3.0, 
        maxFlow: 1.0 
      }
    },
    drain: {
      atmospheric: { 
        ambientPressure: 1.0, 
        maxCapacity: Infinity 
      },
      pressurized: { 
        ambientPressure: 2.0, 
        backpressure: 0.5 
      }
    }
  },
  
  // ============================================================================
  // GLOBAL SETTINGS
  // ============================================================================
  settings: {
    // Simulation
    timeStep: 0.016,          // Target dt (60 FPS)
    maxTimeStep: 0.1,         // Cap dt to prevent instability
    
    // Physics
    gravity: 9.81,            // m/s¬≤
    fluidDensity: 1000,       // kg/m¬≥ (water)
    
    // UI
    updateInterval: 16,       // Update UI every 16ms (60 FPS)
    
    // Debug
    debugMode: true,          // Show debug info in console
    logFlows: false           // Log flow rates to console
  }
};

// ============================================================================
// HELPER: Validate configuration
// ============================================================================
function validateConfig(config) {
  const errors = [];
  const warnings = [];
  
  // Build list of all component IDs
  const allComponentIds = new Set();
  
  for (const [category, items] of Object.entries(config)) {
    if (category === 'settings' || category === 'templates') continue;
    
    for (const [key, item] of Object.entries(items)) {
      if (!item.id) {
        errors.push(`${category}.${key} missing ID`);
        continue;
      }
      
      // Check for duplicate IDs
      if (allComponentIds.has(item.id)) {
        errors.push(`Duplicate ID found: ${item.id}`);
      }
      allComponentIds.add(item.id);
    }
  }
  
  // Validate connections
  for (const [category, items] of Object.entries(config)) {
    if (category === 'settings' || category === 'templates') continue;
    
    for (const [key, item] of Object.entries(items)) {
      // Check inputs
      if (item.inputs) {
        for (const inputId of item.inputs) {
          if (!allComponentIds.has(inputId)) {
            errors.push(`${item.id}.inputs references missing component: ${inputId}`);
          }
        }
      }
      
      // Check outputs
      if (item.outputs) {
        for (const outputId of item.outputs) {
          if (!allComponentIds.has(outputId)) {
            errors.push(`${item.id}.outputs references missing component: ${outputId}`);
          }
        }
      }
      
      // Check boundary components
      if (item.type === 'feed' && item.inputs && item.inputs.length > 0) {
        warnings.push(`${item.id} is a feed but has inputs (should be empty)`);
      }
      if (item.type === 'drain' && item.outputs && item.outputs.length > 0) {
        warnings.push(`${item.id} is a drain but has outputs (should be empty)`);
      }
    }
  }
  
  // Report results
  if (errors.length > 0) {
    console.error('‚ùå Configuration validation errors:', errors);
    return false;
  }
  
  if (warnings.length > 0) {
    console.warn('‚ö†Ô∏è Configuration warnings:', warnings);
  }
  
  console.log('‚úì Configuration validated successfully');
  return true;
}

// ============================================================================
// EXPORT
// ============================================================================
window.SYSTEM_CONFIG = SYSTEM_CONFIG;
window.validateConfig = validateConfig;

// Auto-validate on load
if (validateConfig(SYSTEM_CONFIG)) {
  console.log('‚úÖ System configuration loaded and validated');
  console.log('üìã Components:', {
    feeds: Object.keys(SYSTEM_CONFIG.feeds || {}).length,
    tanks: Object.keys(SYSTEM_CONFIG.tanks || {}).length,
    pumps: Object.keys(SYSTEM_CONFIG.pumps || {}).length,
    valves: Object.keys(SYSTEM_CONFIG.valves || {}).length,
    drains: Object.keys(SYSTEM_CONFIG.drains || {}).length,
    pressureSensors: Object.keys(SYSTEM_CONFIG.pressureSensors || {}).length
  });
}

</script>

</body>
</html>