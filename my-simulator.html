<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>My Simulator</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, #1e3a8a 0%, #1e293b 100%);
      color: #f1f5f9;
      height: 100vh;
      overflow: hidden;
    }
    
    #canvas {
      width: 100%;
      height: 100%;
      background: #0f172a;
    }
    
    .component {
      cursor: pointer;
      transition: opacity 0.2s;
    }
    .component:hover {
      opacity: 0.8;
    }
    
    .label {
      fill: #94a3b8;
      font-size: 12px;
      pointer-events: none;
    }
    
    /* Preserve SVG inline styles */
    .comp-skin {
      /* Let SVG attributes handle fill/stroke */
    }
  </style>
</head>
<body>

<svg id="canvas" viewBox="0 0 1000 600" xmlns="http://www.w3.org/2000/svg">
  <defs>

  </defs>
  
  <g id="pipes">

  </g>
  
  <g id="components">
<g id="tank_1761158145369" class="component Missing" transform="translate(320, 153)">
  <rect x="-20" y="-20" width="40" height="40" fill="#fee" stroke="#c00" stroke-width="2"/>
  <text class="label" x="0" y="-30" text-anchor="middle" font-size="12">Tank</text>
</g>
<g id="feed_1761158147297" class="component Missing" transform="translate(269, 119)">
  <rect x="-20" y="-20" width="40" height="40" fill="#fee" stroke="#c00" stroke-width="2"/>
  <text class="label" x="0" y="-30" text-anchor="middle" font-size="12">Feed (Water Supply)</text>
</g>
<g id="pumpFixed_1761158149625" class="component Missing" transform="translate(627, 184)">
  <rect x="-20" y="-20" width="40" height="40" fill="#fee" stroke="#c00" stroke-width="2"/>
  <text class="label" x="0" y="-30" text-anchor="middle" font-size="12">Fixed Speed Pump</text>
</g>
<g id="pumpVariable_1761158201082" class="component Missing" transform="translate(308, 346)">
  <rect x="-20" y="-20" width="40" height="40" fill="#fee" stroke="#c00" stroke-width="2"/>
  <text class="label" x="0" y="-30" text-anchor="middle" font-size="12">Variable Speed Pump</text>
</g>
<g id="pump3Speed_1761158202322" class="component Missing" transform="translate(369, 348)">
  <rect x="-20" y="-20" width="40" height="40" fill="#fee" stroke="#c00" stroke-width="2"/>
  <text class="label" x="0" y="-30" text-anchor="middle" font-size="12">3-Speed Pump</text>
</g>
<g id="valve_1761158203474" class="component Missing" transform="translate(764, 185)">
  <rect x="-20" y="-20" width="40" height="40" fill="#fee" stroke="#c00" stroke-width="2"/>
  <text class="label" x="0" y="-30" text-anchor="middle" font-size="12">Control Valve</text>
</g>
  </g>
</svg>

<script id="design-data" type="application/json">
{
  "metadata": {
    "exportedAt": "2025-10-22T18:37:18.227Z",
    "exporter": "v5.3.0",
    "baseUrl": "https://sco314.github.io/tank-sim/",
    "name": "My Simulator"
  },
  "components": [
    {
      "id": "tank_1761158145369",
      "name": "Tank",
      "type": "tank",
      "x": 320,
      "y": 153,
      "orientation": "R",
      "variant": "std",
      "ports": [
        {
          "id": "cp_top",
          "name": "top",
          "type": "input",
          "x": 0,
          "y": -180
        },
        {
          "id": "cp_bottom",
          "name": "bottom",
          "type": "output",
          "x": 0,
          "y": 180
        },
        {
          "id": "cp_left",
          "name": "left",
          "type": "both",
          "x": -160,
          "y": 0
        },
        {
          "id": "cp_right",
          "name": "right",
          "type": "both",
          "x": 160,
          "y": 0
        }
      ]
    },
    {
      "id": "feed_1761158147297",
      "name": "Feed (Water Supply)",
      "type": "feed",
      "x": 269,
      "y": 119,
      "orientation": "R",
      "variant": "std",
      "ports": [
        {
          "id": "cp_outlet",
          "name": "outlet",
          "type": "output",
          "x": 20,
          "y": 0
        }
      ]
    },
    {
      "id": "pumpFixed_1761158149625",
      "name": "Fixed Speed Pump",
      "type": "pumpFixed",
      "x": 627,
      "y": 184,
      "orientation": "left",
      "variant": "std",
      "ports": [
        {
          "id": "cp_inlet",
          "name": "inlet",
          "type": "input",
          "x": -60,
          "y": 0
        },
        {
          "id": "cp_outlet",
          "name": "outlet",
          "type": "output",
          "x": 60,
          "y": 0
        }
      ]
    },
    {
      "id": "pumpVariable_1761158201082",
      "name": "Variable Speed Pump",
      "type": "pumpVariable",
      "x": 308,
      "y": 346,
      "orientation": "left",
      "variant": "std",
      "ports": [
        {
          "id": "cp_inlet",
          "name": "inlet",
          "type": "input",
          "x": -60,
          "y": 0
        },
        {
          "id": "cp_outlet",
          "name": "outlet",
          "type": "output",
          "x": 60,
          "y": 0
        }
      ]
    },
    {
      "id": "pump3Speed_1761158202322",
      "name": "3-Speed Pump",
      "type": "pump3Speed",
      "x": 369,
      "y": 348,
      "orientation": "left",
      "variant": "std",
      "ports": [
        {
          "id": "cp_inlet",
          "name": "inlet",
          "type": "input",
          "x": -60,
          "y": 0
        },
        {
          "id": "cp_outlet",
          "name": "outlet",
          "type": "output",
          "x": 60,
          "y": 0
        }
      ]
    },
    {
      "id": "valve_1761158203474",
      "name": "Control Valve",
      "type": "valve",
      "x": 764,
      "y": 185,
      "orientation": "right",
      "variant": "std",
      "ports": [
        {
          "id": "cp_inlet",
          "name": "inlet",
          "type": "input",
          "x": -12.5,
          "y": 0
        },
        {
          "id": "cp_outlet",
          "name": "outlet",
          "type": "output",
          "x": 12.5,
          "y": 0
        }
      ]
    }
  ],
  "pipes": []
}
</script>

<script>

// === js/core/Component.js ===
/**
 * Component.js - Base class for all system components
 * 
 * All components (tanks, pumps, valves, pipes, feeds, drains) inherit from this.
 * Supports boundary components with no inputs (feeds) or no outputs (drains).
 */

class Component {
  constructor(config) {
    this.id = config.id;
    this.type = config.type; // 'tank', 'pump', 'valve', 'pipe', 'sensor', 'feed', 'drain'
    this.name = config.name || this.id;
    
    // CRITICAL: Store flowNetwork reference
    this.flowNetwork = config.flowNetwork || null;
    
    // Flow connections
    this.inputs = config.inputs || [];
    this.outputs = config.outputs || [];
    
    // Visual
    this.svgElement = config.svgElement || null;
    this.position = config.position || [0, 0]; // [x, y]
    
    // State
    this.enabled = config.enabled !== false; // Default enabled
    this.state = {}; // Component-specific state
    
    // Callbacks
    this.onChange = null; // Called when component changes
    
    // Validate configuration
    this._validateConfiguration();
    
    console.log(`Component created: ${this.type} - ${this.id}`);
  }

  /**
   * Validate component configuration
   * Relaxed for boundary components (feeds can have no inputs, drains can have no outputs)
   */
  _validateConfiguration() {
    // Check for required fields
    if (!this.id) {
      console.error('Component must have an ID');
      return;
    }
    
    if (!this.type) {
      console.error(`Component ${this.id} must have a type`);
      return;
    }
    
    // Boundary components have relaxed validation
    if (this.isBoundary()) {
      if (this.type === 'feed' || this.type === 'source') {
        // Feeds/sources should have NO inputs, but must have outputs
        if (this.inputs.length > 0) {
          console.warn(`${this.type} ${this.id} should not have inputs (boundary condition)`);
        }
        if (this.outputs.length === 0) {
          console.warn(`${this.type} ${this.id} has no outputs - will not supply flow to anything`);
        }
      } else if (this.type === 'drain' || this.type === 'sink') {
        // Drains/sinks should have NO outputs, but must have inputs
        if (this.outputs.length > 0) {
          console.warn(`${this.type} ${this.id} should not have outputs (boundary condition)`);
        }
        if (this.inputs.length === 0) {
          console.warn(`${this.type} ${this.id} has no inputs - will not receive flow from anything`);
        }
      }
    } else {
      // Non-boundary components should generally have both inputs and outputs
      // (though some exceptions like sensors might only have inputs)
      if (this.inputs.length === 0 && this.type !== 'sensor') {
        console.warn(`${this.type} ${this.id} has no inputs - may not receive flow`);
      }
      if (this.outputs.length === 0 && this.type !== 'sensor') {
        console.warn(`${this.type} ${this.id} has no outputs - may not supply flow`);
      }
    }
  }

  /**
   * Check if this component is a boundary node (source or sink)
   * Override in subclasses or check type
   */
  isBoundary() {
    return this.type === 'feed' || 
           this.type === 'source' || 
           this.type === 'drain' || 
           this.type === 'sink';
  }

  /**
   * Get DOM element
   */
  getElement() {
    if (!this.svgElement) return null;
    if (typeof this.svgElement === 'string') {
      return document.querySelector(this.svgElement);
    }
    return this.svgElement;
  }

  /**
   * Enable/disable component
   */
  setEnabled(enabled) {
    this.enabled = !!enabled;
    this.notifyChange();
  }

  isEnabled() {
    return this.enabled;
  }

  /**
   * Notify system of changes
   */
  notifyChange() {
    if (this.onChange) {
      this.onChange(this);
    }
  }

  /**
   * Get input flow (override in subclasses)
   */
  getInputFlow() {
    return 0;
  }

  /**
   * Get output flow (override in subclasses)
   */
  getOutputFlow() {
    return 0;
  }

  /**
   * Update component state (override in subclasses)
   */
  update(dt) {
    // Override in subclasses
  }

  /**
   * Render visual representation (override in subclasses)
   */
  render() {
    // Override in subclasses
  }

  /**
   * Get component info for debugging
   */
  getInfo() {
    return {
      id: this.id,
      type: this.type,
      name: this.name,
      enabled: this.enabled,
      isBoundary: this.isBoundary(),
      inputs: this.inputs,
      outputs: this.outputs,
      state: this.state
    };
  }

  /**
   * Reset component to initial state (override in subclasses)
   */
  reset() {
    this.enabled = true;
    this.state = {};
  }

  /**
   * Destroy component (cleanup)
   */
  destroy() {
    this.onChange = null;
    this.svgElement = null;
    this.flowNetwork = null;
  }
}

// Export
window.Component = Component;


// === js/core/FlowNetwork.js ===
/**
 * FlowNetwork.js - Manages flow calculations between components
 * 
 * Component-only topology: no pipes in flow routing
 * Supports boundary conditions (feeds and drains)
 */

class FlowNetwork {
  constructor() {
    this.components = new Map(); // Map<id, Component>
    this.flows = new Map(); // Map<'from->to', flowRate>
    this.pressures = new Map(); // Map<id, pressure> (optional)
  }

  /**
   * Register a component in the network
   */
  addComponent(component) {
    if (!component.id) {
      console.error('Component must have an ID');
      return;
    }
    
    // Store reference to this network in the component
    component.flowNetwork = this;
    
    this.components.set(component.id, component);
    console.log(`Added ${component.type} to flow network: ${component.id}`);
  }

  /**
   * Remove a component from the network
   */
  removeComponent(componentId) {
    const component = this.components.get(componentId);
    if (component) {
      component.flowNetwork = null;
    }
    
    this.components.delete(componentId);
    
    // Clear flows involving this component
    for (const [key, value] of this.flows.entries()) {
      if (key.includes(componentId)) {
        this.flows.delete(key);
      }
    }
  }

  /**
   * Get a component by ID
   */
  getComponent(id) {
    return this.components.get(id);
  }

  /**
   * Get all components of a specific type
   */
  getComponentsByType(type) {
    const result = [];
    for (const component of this.components.values()) {
      if (component.type === type) {
        result.push(component);
      }
    }
    return result;
  }

  /**
   * Set flow rate between two components
   */
  setFlow(fromId, toId, flowRate) {
    const key = `${fromId}->${toId}`;
    this.flows.set(key, flowRate);
  }

  /**
   * Get flow rate between two components
   */
  getFlow(fromId, toId) {
    const key = `${fromId}->${toId}`;
    return this.flows.get(key) || 0;
  }

  /**
   * Get total input flow to a component
   */
  getInputFlow(componentId) {
    let total = 0;
    for (const [key, flow] of this.flows.entries()) {
      if (key.endsWith(`->${componentId}`)) {
        total += flow;
      }
    }
    return total;
  }

  /**
   * Get total output flow from a component
   */
  getOutputFlow(componentId) {
    let total = 0;
    for (const [key, flow] of this.flows.entries()) {
      if (key.startsWith(`${componentId}->`)) {
        total += flow;
      }
    }
    return total;
  }

  /**
   * Calculate all flows in the network
   * Component-only topology with boundary handling
   */
  calculateFlows(dt) {
    // Clear existing flows
    this.flows.clear();

    // CRITICAL: Processing order for component-only topology
    // - 'feed': Boundary sources (infinite supply)
    // - 'valve': Flow controllers
    // - 'pump': Active movers (creates tank->pump flow)
    // - 'drain': Boundary sinks (infinite capacity)
    // - 'sensor': Monitors only
    // 
    // NOTE: 'tank' is NOT in the list - tanks are passive
    // NOTE: 'pipe' is NOT in the list - pipes are visual only
    const order = ['feed', 'valve', 'pump', 'drain', 'sensor'];
    
    for (const type of order) {
      const components = this.getComponentsByType(type);
      
      for (const component of components) {
        if (!component.enabled) continue;
        
        // Calculate output flow for this component
        const outputFlow = component.getOutputFlow();
        
        // Distribute flow to all outputs
        if (component.outputs && component.outputs.length > 0) {
          const flowPerOutput = outputFlow / component.outputs.length;
          
          for (const outputId of component.outputs) {
            this.setFlow(component.id, outputId, flowPerOutput);
          }
        }
      }
    }
    
    // BOUNDARY HANDLING: Ensure boundary conditions are satisfied
    this._applyBoundaryConditions();
  }

  /**
   * Apply boundary conditions (feeds and drains)
   */
  _applyBoundaryConditions() {
    // Feeds inject flow at their outputs
    const feeds = this.getComponentsByType('feed');
    for (const feed of feeds) {
      if (!feed.enabled) continue;
      
      // Feed provides flow based on downstream demand
      // This is already handled in calculateFlows, but we could
      // add pressure-based calculations here in the future
    }
    
    // Drains accept all incoming flow
    const drains = this.getComponentsByType('drain');
    for (const drain of drains) {
      if (!drain.enabled) continue;
      
      // Drain accepts whatever flows into it
      // No action needed - just verify flow is recorded
      const inflow = this.getInputFlow(drain.id);
      if (inflow > 0) {
        // Flow successfully reaches drain
      }
    }
  }

  /**
   * Update all components in the network
   */
  updateComponents(dt) {
    for (const component of this.components.values()) {
      if (component.enabled) {
        component.update(dt);
      }
    }
  }

  /**
   * Render all components
   */
  renderComponents() {
    for (const component of this.components.values()) {
      component.render();
    }
  }

  /**
   * Build network from config and validate
   * Component-only topology with clear error messages
   */
  buildFromConfig(config) {
    console.log('Building flow network from config...');
    
    // Components are added by their respective managers
    // This method validates connections
    
    let validConnections = 0;
    let invalidConnections = 0;
    const errors = [];
    
    for (const component of this.components.values()) {
      // Check if all inputs exist and are valid
      for (const inputId of component.inputs) {
        const inputComponent = this.components.get(inputId);
        
        if (inputComponent) {
          validConnections++;
        } else {
          // CLEAR ERROR MESSAGE
          const errorMsg = `Component "${component.id}" (${component.type}) has invalid input: "${inputId}" - component does not exist`;
          errors.push(errorMsg);
          console.error(`❌ ${errorMsg}`);
          invalidConnections++;
        }
      }
      
      // Check if all outputs exist and are valid
      for (const outputId of component.outputs) {
        const outputComponent = this.components.get(outputId);
        
        if (outputComponent) {
          validConnections++;
        } else {
          // CLEAR ERROR MESSAGE
          const errorMsg = `Component "${component.id}" (${component.type}) has invalid output: "${outputId}" - component does not exist`;
          errors.push(errorMsg);
          console.error(`❌ ${errorMsg}`);
          invalidConnections++;
        }
      }
      
      // Validate boundary components
      if (component.isBoundary && component.isBoundary()) {
        if (component.type === 'feed' && component.inputs.length > 0) {
          console.warn(`⚠️ Feed "${component.id}" has inputs - feeds should have no inputs (boundary condition)`);
        }
        if (component.type === 'drain' && component.outputs.length > 0) {
          console.warn(`⚠️ Drain "${component.id}" has outputs - drains should have no outputs (boundary condition)`);
        }
      }
    }
    
    // Report results
    const summary = `Network built: ${this.components.size} components, ${validConnections} valid connections, ${invalidConnections} invalid`;
    
    if (invalidConnections > 0) {
      console.error(`❌ ${summary}`);
      console.error('❌ Invalid connections found:', errors);
    } else {
      console.log(`✅ ${summary}`);
    }
    
    // Log topology for debugging
    if (invalidConnections === 0) {
      this._logTopology();
    }
  }

  /**
   * Log network topology for debugging
   */
  _logTopology() {
    console.log('📊 Network Topology:');
    
    // Find the flow path from feed to drain
    const feeds = this.getComponentsByType('feed');
    const drains = this.getComponentsByType('drain');
    
    if (feeds.length > 0 && drains.length > 0) {
      const path = this._findPath(feeds[0].id, drains[0].id);
      if (path) {
        console.log('Flow path:', path.join(' → '));
      }
    }
    
    // List all components by type
    const types = ['feed', 'valve', 'tank', 'pump', 'drain', 'sensor', 'pipe'];
    for (const type of types) {
      const components = this.getComponentsByType(type);
      if (components.length > 0) {
        console.log(`  ${type}s (${components.length}):`, components.map(c => c.id).join(', '));
      }
    }
  }

  /**
   * Find path between two components (for debugging)
   */
  _findPath(startId, endId, visited = new Set()) {
    if (startId === endId) return [endId];
    if (visited.has(startId)) return null;
    
    visited.add(startId);
    const component = this.getComponent(startId);
    if (!component) return null;
    
    for (const outputId of component.outputs) {
      const path = this._findPath(outputId, endId, visited);
      if (path) {
        return [startId, ...path];
      }
    }
    
    return null;
  }

  /**
   * Get network info for debugging
   */
  getNetworkInfo() {
    const info = {
      componentCount: this.components.size,
      components: [],
      flows: [],
      boundaries: {
        feeds: [],
        drains: []
      }
    };
    
    for (const component of this.components.values()) {
      const componentInfo = component.getInfo();
      info.components.push(componentInfo);
      
      // Track boundary components
      if (component.type === 'feed') {
        info.boundaries.feeds.push(component.id);
      } else if (component.type === 'drain') {
        info.boundaries.drains.push(component.id);
      }
    }
    
    for (const [key, flow] of this.flows.entries()) {
      info.flows.push({ connection: key, flow });
    }
    
    return info;
  }

  /**
   * Verify network integrity (diagnostic tool)
   */
  verifyIntegrity() {
    console.log('🔍 Verifying network integrity...');
    
    const issues = [];
    
    // Check for orphaned components
    for (const component of this.components.values()) {
      if (component.type === 'feed' || component.type === 'drain') continue;
      
      if (component.inputs.length === 0 && component.outputs.length === 0) {
        issues.push(`Component "${component.id}" is orphaned (no connections)`);
      }
    }
    
    // Check for flow continuity
    const feeds = this.getComponentsByType('feed');
    const drains = this.getComponentsByType('drain');
    
    if (feeds.length === 0) {
      issues.push('No feed (source) components found - system has no inlet');
    }
    
    if (drains.length === 0) {
      issues.push('No drain (sink) components found - system has no outlet');
    }
    
    // Check for path from feed to drain
    if (feeds.length > 0 && drains.length > 0) {
      const path = this._findPath(feeds[0].id, drains[0].id);
      if (!path) {
        issues.push('No valid flow path from feed to drain');
      }
    }
    
    if (issues.length > 0) {
      console.warn('⚠️ Network integrity issues:', issues);
      return false;
    } else {
      console.log('✅ Network integrity verified');
      return true;
    }
  }

  /**
   * Reset entire network
   */
  reset() {
    this.flows.clear();
    this.pressures.clear();
    
    for (const component of this.components.values()) {
      component.reset();
    }
    
    console.log('Flow network reset');
  }

  /**
   * Clear network
   */
  clear() {
    for (const component of this.components.values()) {
      component.destroy();
    }
    
    this.components.clear();
    this.flows.clear();
    this.pressures.clear();
    
    console.log('Flow network cleared');
  }
}

// Export
window.FlowNetwork = FlowNetwork;


// === js/core/ComponentManager.js ===
/**
 * ComponentManager.js - Master orchestrator with boundary component support
 */

class ComponentManager {
  constructor(config) {
    this.config = config;
    this.flowNetwork = new FlowNetwork();
    
    // Component managers
    this.valveManager = null;
    this.pumpManager = null;
    this.tankManager = null;
    this.pipeManager = null;
    this.pressureManager = null;
    
    // Boundary components (no managers needed - simple instantiation)
    this.feeds = {};
    this.drains = {};
    
    // Simulation state
    this.running = false;
    this.paused = false;
    this.lastTime = performance.now();
    
    console.log('ComponentManager initialized');
  }

  /**
   * Initialize all component managers
   */
  async initialize() {
    console.log('Initializing component managers...');
    
    try {
      // CRITICAL: Initialize in correct order
      // 1. Boundary conditions first
      await this._initializeBoundaries();
      
      // 2. Physical components
      await this._initializeTanks();
      await this._initializePumps();
      await this._initializeValves();
      
      // 3. Sensors and visual elements
      await this._initializePressureSensors();
      await this._initializePipes();
      
      // Build and validate flow network
      this.flowNetwork.buildFromConfig(this.config);
      this.flowNetwork.verifyIntegrity();
      
      console.log('All component managers initialized successfully');
      return true;
    } catch (error) {
      console.error('Failed to initialize component managers:', error);
      return false;
    }
  }

  /**
   * Initialize boundary conditions (feeds and drains)
   */
  async _initializeBoundaries() {
    // Initialize feeds
    if (this.config.feeds && window.Feed) {
      for (const [key, cfg] of Object.entries(this.config.feeds)) {
        const feed = new Feed(cfg);
        this.feeds[key] = feed;
        this.flowNetwork.addComponent(feed);
        console.log(`✓ Feed created: ${feed.id}`);
      }
    }
    
    // Initialize drains
    if (this.config.drains && window.Drain) {
      for (const [key, cfg] of Object.entries(this.config.drains)) {
        const drain = new Drain(cfg);
        this.drains[key] = drain;
        this.flowNetwork.addComponent(drain);
        console.log(`✓ Drain created: ${drain.id}`);
      }
    }
    
    console.log('✓ Boundary components ready');
  }

  /**
   * Initialize tank manager
   */
  async _initializeTanks() {
    if (!this.config.tanks || !window.TankManager) return;
    
    this.tankManager = new TankManager(this.config.tanks, this.flowNetwork);
    console.log('✓ TankManager ready');
  }

  /**
   * Initialize pump manager
   */
  async _initializePumps() {
    if (!this.config.pumps || !window.PumpManager) return;
    
    this.pumpManager = new PumpManager(this.config.pumps, this.flowNetwork);
    console.log('✓ PumpManager ready');
  }

  /**
   * Initialize valve manager
   */
  async _initializeValves() {
    if (!this.config.valves || !window.ValveManager) return;
    
    this.valveManager = new ValveManager(this.config.valves, this.flowNetwork);
    console.log('✓ ValveManager ready');
  }

  /**
   * Initialize pipe manager (VISUAL ONLY)
   */
  async _initializePipes() {
    if (!this.config.pipes || !window.PipeManager) return;
    
    this.pipeManager = new PipeManager(this.config.pipes, this.flowNetwork);
    console.log('✓ PipeManager ready (visual only)');
  }

  /**
   * Initialize pressure sensor manager
   */
  async _initializePressureSensors() {
    if (!this.config.pressureSensors || !window.PressureManager) return;
    
    this.pressureManager = new PressureManager(this.config.pressureSensors, this.flowNetwork);
    console.log('✓ PressureManager ready');
  }

  /**
   * Start simulation
   */
  start() {
    if (this.running) return;
    
    this.running = true;
    this.paused = false;
    this.lastTime = performance.now();
    
    this._simulationLoop();
    console.log('Simulation started');
  }

  /**
   * Pause simulation
   */
  pause() {
    this.paused = true;
    console.log('Simulation paused');
  }

  /**
   * Resume simulation
   */
  resume() {
    if (!this.running) {
      this.start();
      return;
    }
    
    this.paused = false;
    this.lastTime = performance.now();
    console.log('Simulation resumed');
  }

  /**
   * Stop simulation
   */
  stop() {
    this.running = false;
    this.paused = false;
    console.log('Simulation stopped');
  }

  /**
   * Main simulation loop
   */
  _simulationLoop() {
    if (!this.running) return;
    
    const now = performance.now();
    const dt = Math.min(0.1, (now - this.lastTime) / 1000);
    this.lastTime = now;
    
    if (!this.paused) {
      // Calculate flows in the network
      this.flowNetwork.calculateFlows(dt);
      
      // Update all components
      this.flowNetwork.updateComponents(dt);
      
      // Render all components
      this.flowNetwork.renderComponents();
    }
    
    // Continue loop
    requestAnimationFrame(() => this._simulationLoop());
  }

  /**
   * Reset all components
   */
  reset() {
    this.flowNetwork.reset();
    
    if (this.tankManager) this.tankManager.reset();
    if (this.pumpManager) this.pumpManager.reset();
    if (this.valveManager) this.valveManager.reset();
    if (this.pipeManager) this.pipeManager.reset();
    if (this.pressureManager) this.pressureManager.reset();
    
    // Reset boundaries
    for (const feed of Object.values(this.feeds)) {
      feed.reset();
    }
    for (const drain of Object.values(this.drains)) {
      drain.reset();
    }
    
    console.log('All components reset');
  }

  /**
   * Get component by ID
   */
  getComponent(id) {
    return this.flowNetwork.getComponent(id);
  }

  /**
   * Get system info
   */
  getSystemInfo() {
    return {
      running: this.running,
      paused: this.paused,
      network: this.flowNetwork.getNetworkInfo(),
      managers: {
        feeds: Object.keys(this.feeds).length,
        tanks: this.tankManager ? Object.keys(this.tankManager.tanks || {}).length : 0,
        pumps: this.pumpManager ? Object.keys(this.pumpManager.pumps || {}).length : 0,
        valves: this.valveManager ? Object.keys(this.valveManager.valves || {}).length : 0,
        drains: Object.keys(this.drains).length,
        pipes: this.pipeManager ? Object.keys(this.pipeManager.pipes || {}).length : 0,
        pressureSensors: this.pressureManager ? Object.keys(this.pressureManager.sensors || {}).length : 0
      }
    };
  }

  /**
   * Destroy and cleanup
   */
  destroy() {
    this.stop();
    
    if (this.tankManager) this.tankManager.destroy();
    if (this.pumpManager) this.pumpManager.destroy();
    if (this.valveManager) this.valveManager.destroy();
    if (this.pipeManager) this.pipeManager.destroy();
    if (this.pressureManager) this.pressureManager.destroy();
    
    for (const feed of Object.values(this.feeds)) {
      feed.destroy();
    }
    for (const drain of Object.values(this.drains)) {
      drain.destroy();
    }
    
    this.flowNetwork.clear();
    
    console.log('ComponentManager destroyed');
  }
}

// Export
window.ComponentManager = ComponentManager;


// === js/managers/PipeManager.js ===
/**
 * PipeManager.js - Manages all pipes and flow animations
 * 
 * Controls flow visualization throughout the system
 */

class PipeManager {
  constructor(config, flowNetwork) {
    this.config = config;
    this.flowNetwork = flowNetwork;
    this.pipes = {};
    
    this._initializePipes();
    this._setupFlowMonitoring();
    
    console.log(`PipeManager initialized with ${Object.keys(this.pipes).length} pipes`);
  }

  /**
   * Initialize all pipes from config
   */
  _initializePipes() {
    for (const [key, cfg] of Object.entries(this.config)) {
      const pipe = new Pipe({
        ...cfg,
        flowNetwork: this.flowNetwork
      });
      
      this.pipes[key] = pipe;
      this.flowNetwork.addComponent(pipe);
      
      // Setup change callback
      pipe.onChange = (p) => this._onPipeChange(key, p);
    }
  }

  /**
   * Setup flow monitoring for debug
   */
  _setupFlowMonitoring() {
    // Optional: log significant flow changes
    this.lastLogTime = performance.now();
    this.logInterval = 5000; // Log every 5 seconds
  }

  /**
   * Called when pipe state changes
   */
  _onPipeChange(key, pipe) {
    // Optional: log flow changes
    const now = performance.now();
    if (now - this.lastLogTime > this.logInterval) {
      if (pipe.flowRate > 0.001) {
        console.log(`Pipe ${key}: ${pipe.flowRate.toFixed(2)} m³/s (${pipe.getFlowRegime()})`);
      }
      this.lastLogTime = now;
    }
  }

  /**
   * Get pipe by key
   */
  getPipe(key) {
    return this.pipes[key];
  }

  /**
   * Get all pipes
   */
  getAllPipes() {
    return this.pipes;
  }

  /**
   * Get all active flows (pipes with flow > 0)
   */
  getActiveFlows() {
    const active = [];
    for (const [key, pipe] of Object.entries(this.pipes)) {
      if (pipe.flowRate > 0.001) {
        active.push({
          pipe: key,
          name: pipe.name,
          flowRate: pipe.flowRate,
          velocity: pipe.velocity
        });
      }
    }
    return active;
  }

  /**
   * Get total system flow rate
   */
  getTotalFlow() {
    let total = 0;
    for (const pipe of Object.values(this.pipes)) {
      total += pipe.flowRate;
    }
    return total;
  }

  /**
   * Get highest flow rate
   */
  getMaxFlow() {
    let max = 0;
    for (const pipe of Object.values(this.pipes)) {
      if (pipe.flowRate > max) max = pipe.flowRate;
    }
    return max;
  }

  /**
   * Check if any pipe is flowing
   */
  hasActiveFlow() {
    for (const pipe of Object.values(this.pipes)) {
      if (pipe.flowRate > 0.001) return true;
    }
    return false;
  }

  /**
   * Get flow path from component A to component B
   */
  getFlowPath(fromId, toId) {
    const path = [];
    for (const [key, pipe] of Object.entries(this.pipes)) {
      if (pipe.inputs.includes(fromId) && pipe.outputs.includes(toId)) {
        path.push(key);
      }
    }
    return path;
  }

  /**
   * Enable/disable all flow animations
   */
  setAnimationsEnabled(enabled) {
    for (const pipe of Object.values(this.pipes)) {
      if (enabled) {
        pipe.render();
      } else {
        if (pipe.flowPath) {
          pipe.flowPath.classList.remove('on');
        }
      }
    }
  }

  /**
   * Set global animation speed multiplier
   */
  setGlobalAnimationSpeed(speed) {
    for (const pipe of Object.values(this.pipes)) {
      pipe.animationSpeed = speed;
    }
  }

  /**
   * Reset all pipes
   */
  reset() {
    for (const pipe of Object.values(this.pipes)) {
      pipe.reset();
    }
    console.log('All pipes reset');
  }

  /**
   * Destroy and cleanup
   */
  destroy() {
    for (const pipe of Object.values(this.pipes)) {
      pipe.destroy();
    }
    
    this.pipes = {};
  }
}

// Export
window.PipeManager = PipeManager;


// === js/managers/ValveManager.js ===
/**
 * ValveManager.js - Manages all valves with interactive wheel controls
 * 
 * Creates modals with iframe valve controls for each valve
 */

class ValveManager {
  constructor(config, flowNetwork) {
    this.config = config;
    this.flowNetwork = flowNetwork;
    this.valves = {};
    this.modals = {};
    this.iframes = {};
    
    this._initializeValves();
    this._createModals();
    this._setupEventListeners();
    this._setupPostMessageListener();
    
    console.log(`ValveManager initialized with ${Object.keys(this.valves).length} valves`);
  }

  /**
   * Initialize all valves from config
   */
  _initializeValves() {
  for (const [key, cfg] of Object.entries(this.config)) {
    const valve = new Valve({
      ...cfg,
      flowNetwork: this.flowNetwork  // ✅ ADD THIS
    });
    this.valves[key] = valve;
    this.flowNetwork.addComponent(valve);
    
    valve.onChange = (v) => this._onValveChange(key, v);
  }
}

  /**
   * Create modal for each valve with iframe
   */
  _createModals() {
    for (const [key, valve] of Object.entries(this.valves)) {
      const modal = this._createModalElement(key, valve);
      document.body.appendChild(modal);
      this.modals[key] = modal;
      this.iframes[key] = modal.querySelector('iframe');
      
      // Setup iframe communication after it loads
      this._setupIframeSync(key, this.iframes[key]);
    }
  }

  /**
   * Create modal HTML with iframe for a valve
   */
  _createModalElement(key, valve) {
    const overlay = document.createElement('div');
    overlay.id = `${valve.id}Modal`;
    overlay.className = 'valve-modal-overlay';
    overlay.setAttribute('aria-hidden', 'true');
    
    const title = valve.config?.modalTitle || `${valve.name} Control`;
    const iframeUrl = valve.config?.iframeUrl || 'valve.html';
    
    overlay.innerHTML = `
      <div class="valve-modal-container">
        <button type="button" aria-label="Close ${title}" class="valve-modal-close valve-close-btn" data-valve="${key}">×</button>
        <div class="valve-modal-title">${title}</div>
        <iframe src="${iframeUrl}" title="${title}" class="valve-iframe"></iframe>
      </div>
    `;
    
    return overlay;
  }

  /**
   * Setup iframe communication for a valve
   */
  _setupIframeSync(key, iframe) {
    if (!iframe) return;
    
    iframe.addEventListener('load', () => {
      console.log(`Valve iframe loaded: ${key}`);
      
      // Wait for ValveTop to initialize
      setTimeout(() => {
        const valve = this.valves[key];
        
        // Set initial position
        this._sendValvePosition(iframe, valve.position);
        
        // Setup onChange callback (direct API - works on web server)
        try {
          if (iframe.contentWindow && iframe.contentWindow.ValveTop) {
            iframe.contentWindow.ValveTop.onChange((pos) => {
              this._onIframePositionChange(key, pos);
            });
            console.log(`✅ Valve ${key} direct onChange callback set`);
          }
        } catch(e) {
          console.warn(`⚠️ Direct callback failed for valve ${key}, using postMessage fallback`);
        }
      }, 150);
    });
  }

  /**
   * Setup global postMessage listener (fallback for file:// protocol)
   */
  _setupPostMessageListener() {
    window.addEventListener('message', (event) => {
      // Check if message is from a valve iframe
      if (event.data && event.data.type === 'valve:changed') {
        // Find which valve sent this message
        for (const [key, iframe] of Object.entries(this.iframes)) {
          if (event.source === iframe.contentWindow) {
            const position = Math.max(0, Math.min(1, parseFloat(event.data.value) || 0));
            this._onIframePositionChange(key, position);
            console.log(`📨 Valve ${key} updated via postMessage: ${(position * 100).toFixed(0)}%`);
            break;
          }
        }
      }
    });
    console.log('✅ PostMessage listener active for valve updates');
  }

  /**
   * Send position to iframe valve control
   */
  _sendValvePosition(iframe, position) {
    if (!iframe || !iframe.contentWindow) return;
    
    try {
      // Try direct API call
      if (iframe.contentWindow.ValveTop && 
          typeof iframe.contentWindow.ValveTop.set === 'function') {
        iframe.contentWindow.ValveTop.set(position);
        return;
      }
    } catch(e) {
      // Cross-origin or not loaded yet
    }
    
    // Fallback: postMessage
    try {
      iframe.contentWindow.postMessage({
        type: 'valve:set',
        value: position
      }, '*');
    } catch(e) {
      console.warn('Failed to send valve position:', e);
    }
  }

  /**
   * Called when iframe valve position changes
   */
  _onIframePositionChange(key, position) {
    const valve = this.valves[key];
    if (!valve) return;
    
    valve.setPosition(position);
    console.log(`Valve ${key} set to ${(position * 100).toFixed(0)}%`);
  }

  /**
   * Setup event listeners for all valves
   */
  _setupEventListeners() {
    for (const [key, valve] of Object.entries(this.valves)) {
      const svgElement = document.querySelector(valve.svgElement);
      const modal = this.modals[key];
      
      if (!svgElement) {
        console.warn(`SVG element ${valve.svgElement} not found for valve ${key}`);
        continue;
      }
      
      // Click valve to open modal
      svgElement.addEventListener('click', () => this.openModal(key));
      svgElement.addEventListener('keydown', (e) => {
        if (e.key === ' ' || e.key === 'Enter') {
          e.preventDefault();
          this.openModal(key);
        }
      });
      
      // Close button
      const closeBtn = modal.querySelector('.valve-close-btn');
      closeBtn?.addEventListener('click', () => this.closeModal(key));
      
      // Click outside to close
      modal.addEventListener('click', (e) => {
        if (e.target === modal) this.closeModal(key);
      });
    }
    
    // Global escape key handler
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        for (const key of Object.keys(this.modals)) {
          if (this.modals[key].classList.contains('open')) {
            this.closeModal(key);
          }
        }
      }
    });
  }

  /**
   * Open valve modal
   */
  openModal(key) {
    const modal = this.modals[key];
    const valve = this.valves[key];
    
    if (!modal || !valve) return;
    
    modal.classList.add('open');
    modal.setAttribute('aria-hidden', 'false');
    document.body.style.overflow = 'hidden';
    
    // Send current position to iframe
    setTimeout(() => {
      this._sendValvePosition(this.iframes[key], valve.position);
    }, 100);
    
    console.log(`Opened ${valve.name} modal at ${valve.getPositionPercent()}%`);
  }

  /**
   * Close valve modal
   */
  closeModal(key) {
    const modal = this.modals[key];
    if (!modal) return;
    
    modal.classList.remove('open');
    modal.setAttribute('aria-hidden', 'true');
    document.body.style.overflow = '';
  }

  /**
   * Called when valve changes
   * REALISTIC FIELD OPERATION: No visual hints - user must click to check position
   */
  _onValveChange(key, valve) {
    // Update ARIA state for accessibility
    const svgElement = document.querySelector(valve.svgElement);
    if (svgElement) {
      svgElement.setAttribute('aria-pressed', valve.isOpen());
      
      // REMOVED: No opacity changes
      // Valves always look the same regardless of position
      // User must click to check - just like in the field!
    }
    
    console.log(`Valve ${key} changed:`, valve.getInfo());
  }

  /**
   * Get valve by key
   */
  getValve(key) {
    return this.valves[key];
  }

  /**
   * Get all valves
   */
  getAllValves() {
    return this.valves;
  }

  /**
   * Set valve position
   */
  setValvePosition(key, position) {
    const valve = this.valves[key];
    if (!valve) return;
    
    valve.setPosition(position);
    
    // Update iframe if modal is open
    if (this.modals[key]?.classList.contains('open')) {
      this._sendValvePosition(this.iframes[key], position);
    }
  }

  /**
   * Reset all valves
   */
  reset() {
    for (const valve of Object.values(this.valves)) {
      valve.reset();
    }
  }

  /**
   * Destroy and cleanup
   */
  destroy() {
    for (const valve of Object.values(this.valves)) {
      valve.destroy();
    }
    
    for (const modal of Object.values(this.modals)) {
      modal.remove();
    }
    
    this.valves = {};
    this.modals = {};
    this.iframes = {};
  }
}

// Export
window.ValveManager = ValveManager;


// === js/managers/PumpManager.js ===
/**
 * PumpManager.js - Manages all pumps in the system
 * 
 * Creates, configures, and controls all pump types with modal interfaces
 */

class PumpManager {
  constructor(config, flowNetwork) {
    this.config = config;
    this.flowNetwork = flowNetwork;
    this.pumps = {};
    this.modals = {};
    
    this._initializePumps();
    this._createModals();
    this._setupEventListeners();
    
    console.log(`PumpManager initialized with ${Object.keys(this.pumps).length} pumps`);
  }

  /**
   * Initialize all pumps from config
   */
  _initializePumps() {
    for (const [key, cfg] of Object.entries(this.config)) {
      let pump;
      
      // Create appropriate pump type
      switch (cfg.pumpType) {
        case 'fixed':
          pump = new FixedSpeedPump(cfg);
          break;
        case 'variable':
          pump = new VariableSpeedPump(cfg);
          break;
        case '3-speed':
          pump = new ThreeSpeedPump(cfg);
          break;
        default:
          console.warn(`Unknown pump type: ${cfg.pumpType}, defaulting to fixed`);
          pump = new FixedSpeedPump(cfg);
      }
      
      this.pumps[key] = pump;
      this.flowNetwork.addComponent(pump);
      
      // Setup change callback
      pump.onChange = (p) => this._onPumpChange(key, p);
    }
  }

  /**
   * Create modal for each pump
   */
  _createModals() {
    for (const [key, pump] of Object.entries(this.pumps)) {
      const modal = this._createModalElement(key, pump);
      document.body.appendChild(modal);
      this.modals[key] = modal;
    }
  }

  /**
   * Create modal HTML for a pump
   */
  _createModalElement(key, pump) {
    const overlay = document.createElement('div');
    overlay.id = `${pump.id}Modal`;
    overlay.className = 'valve-modal-overlay'; // Reuse valve modal styles
    overlay.setAttribute('aria-hidden', 'true');
    
    const title = pump.config?.modalTitle || `${pump.name} Control`;
    
    // Create modal content based on pump type
    let controlsHTML = '';
    
    if (pump.pumpType === 'fixed') {
      controlsHTML = `
        <div class="pump-controls">
          <button type="button" class="btn toggle pump-toggle" data-pump="${key}" aria-pressed="false">
            Start Pump
          </button>
          <div class="pump-status">
            <div class="kv">
              <div>Status</div><div class="pump-status-text">OFF</div>
              <div>Flow Rate</div><div class="pump-flow">0.00 m³/s</div>
              <div>Run Time</div><div class="pump-runtime">0s</div>
            </div>
          </div>
        </div>
      `;
    } else if (pump.pumpType === 'variable') {
      controlsHTML = `
        <div class="pump-controls">
          <div class="row">
            <button type="button" class="btn pump-stop" data-pump="${key}">Stop</button>
            <button type="button" class="btn toggle pump-toggle" data-pump="${key}" aria-pressed="false">
              Start
            </button>
          </div>
          <div class="row" style="margin-top: 16px;">
            <label for="${pump.id}Speed">Speed</label>
            <input type="range" id="${pump.id}Speed" class="grow pump-speed-slider" 
                   data-pump="${key}" min="0" max="100" step="1" value="0"/>
            <output class="pump-speed-output">0%</output>
          </div>
          <div class="pump-status">
            <div class="kv">
              <div>Status</div><div class="pump-status-text">OFF</div>
              <div>Flow Rate</div><div class="pump-flow">0.00 m³/s</div>
              <div>Run Time</div><div class="pump-runtime">0s</div>
            </div>
          </div>
        </div>
      `;
    } else if (pump.pumpType === '3-speed') {
      controlsHTML = `
        <div class="pump-controls">
          <div class="row">
            <button type="button" class="btn pump-stop" data-pump="${key}">Stop</button>
          </div>
          <div class="row" style="margin-top: 12px; gap: 8px;">
            <button type="button" class="btn pump-speed-btn" data-pump="${key}" data-speed="0">Low</button>
            <button type="button" class="btn pump-speed-btn" data-pump="${key}" data-speed="1">Medium</button>
            <button type="button" class="btn pump-speed-btn" data-pump="${key}" data-speed="2">High</button>
          </div>
          <div class="pump-status">
            <div class="kv">
              <div>Status</div><div class="pump-status-text">OFF</div>
              <div>Speed</div><div class="pump-speed-setting">-</div>
              <div>Flow Rate</div><div class="pump-flow">0.00 m³/s</div>
              <div>Run Time</div><div class="pump-runtime">0s</div>
            </div>
          </div>
        </div>
      `;
    }
    
    // Add cavitation warning if enabled
    if (pump.cavitation.enabled) {
      controlsHTML += `
        <div class="pump-cavitation-warning" style="display: none; margin-top: 16px; padding: 12px; background: rgba(255, 107, 107, 0.1); border: 1px solid #ff6b6b; border-radius: 8px; color: #ff6b6b;">
          ⚠️ <strong>CAVITATION DETECTED</strong><br>
          <small>Flow reduced - Check suction conditions</small>
        </div>
      `;
    }
    
    overlay.innerHTML = `
      <div class="valve-modal-container">
        <button type="button" aria-label="Close ${title}" class="valve-modal-close pump-modal-close" data-pump="${key}">×</button>
        <div class="valve-modal-title">${title}</div>
        <div style="padding: 20px;">
          ${controlsHTML}
        </div>
      </div>
    `;
    
    return overlay;
  }

  /**
   * Setup event listeners for all pumps and modals
   */
  _setupEventListeners() {
    for (const [key, pump] of Object.entries(this.pumps)) {
      const svgElement = document.querySelector(pump.svgElement);
      const modal = this.modals[key];
      
      if (!svgElement) {
        console.warn(`SVG element ${pump.svgElement} not found for pump ${key}`);
        continue;
      }
      
      // Click pump to open modal
      svgElement.addEventListener('click', () => this.openModal(key));
      svgElement.addEventListener('keydown', (e) => {
        if (e.key === ' ' || e.key === 'Enter') {
          e.preventDefault();
          this.openModal(key);
        }
      });
      
      // Close button
      const closeBtn = modal.querySelector('.pump-modal-close');
      closeBtn?.addEventListener('click', () => this.closeModal(key));
      
      // Click outside to close
      modal.addEventListener('click', (e) => {
        if (e.target === modal) this.closeModal(key);
      });
      
      // Setup pump-specific controls
      this._setupPumpControls(key, pump, modal);
    }
    
    // Global escape key handler
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        for (const key of Object.keys(this.modals)) {
          if (this.modals[key].classList.contains('open')) {
            this.closeModal(key);
          }
        }
      }
    });
  }

  /**
   * Setup pump-specific controls in modal
   */
  _setupPumpControls(key, pump, modal) {
    if (pump.pumpType === 'fixed') {
      // Fixed speed: toggle button
      const toggle = modal.querySelector('.pump-toggle');
      toggle?.addEventListener('click', () => {
        pump.toggle();
        this._updateModalUI(key);
      });
      
    } else if (pump.pumpType === 'variable') {
      // Variable speed: start, stop, slider
      const startBtn = modal.querySelector('.pump-toggle');
      const stopBtn = modal.querySelector('.pump-stop');
      const slider = modal.querySelector('.pump-speed-slider');
      const output = modal.querySelector('.pump-speed-output');
      
      startBtn?.addEventListener('click', () => {
        pump.start();
        this._updateModalUI(key);
      });
      
      stopBtn?.addEventListener('click', () => {
        pump.stop();
        this._updateModalUI(key);
      });
      
      slider?.addEventListener('input', (e) => {
        const speed = parseInt(e.target.value) / 100;
        pump.setSpeed(speed);
        if (output) output.textContent = e.target.value + '%';
        this._updateModalUI(key);
      });
      
    } else if (pump.pumpType === '3-speed') {
      // 3-speed: stop button + speed buttons
      const stopBtn = modal.querySelector('.pump-stop');
      const speedBtns = modal.querySelectorAll('.pump-speed-btn');
      
      stopBtn?.addEventListener('click', () => {
        pump.stop();
        this._updateModalUI(key);
      });
      
      speedBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          const speedIndex = parseInt(btn.dataset.speed);
          pump.setSpeedIndex(speedIndex);
          this._updateModalUI(key);
        });
      });
    }
  }

  /**
   * Open pump modal
   */
  openModal(key) {
    const modal = this.modals[key];
    if (!modal) return;
    
    modal.classList.add('open');
    modal.setAttribute('aria-hidden', 'false');
    document.body.style.overflow = 'hidden';
    
    this._updateModalUI(key);
    
    console.log(`Opened ${this.pumps[key].name} modal`);
  }

  /**
   * Close pump modal
   */
  closeModal(key) {
    const modal = this.modals[key];
    if (!modal) return;
    
    modal.classList.remove('open');
    modal.setAttribute('aria-hidden', 'true');
    document.body.style.overflow = '';
  }

  /**
   * Update modal UI to reflect pump state
   */
  _updateModalUI(key) {
    const pump = this.pumps[key];
    const modal = this.modals[key];
    if (!modal) return;
    
    // Update status text
    const statusText = modal.querySelector('.pump-status-text');
    if (statusText) {
      statusText.textContent = pump.running ? 'RUNNING' : 'OFF';
      statusText.style.color = pump.running ? '#3ddc97' : '#9bb0ff';
    }
    
    // Update flow rate
    const flowText = modal.querySelector('.pump-flow');
    if (flowText) {
      flowText.textContent = pump.getOutputFlow().toFixed(2) + ' m³/s';
    }
    
    // Update runtime
    const runtimeText = modal.querySelector('.pump-runtime');
    if (runtimeText) {
      runtimeText.textContent = Math.floor(pump.runTime) + 's';
    }
    
    // Update pump-type-specific UI
    if (pump.pumpType === 'fixed') {
      const toggle = modal.querySelector('.pump-toggle');
      if (toggle) {
        toggle.setAttribute('aria-pressed', pump.running);
        toggle.textContent = pump.running ? 'Stop Pump' : 'Start Pump';
      }
      
    } else if (pump.pumpType === 'variable') {
      const slider = modal.querySelector('.pump-speed-slider');
      const output = modal.querySelector('.pump-speed-output');
      if (slider && output) {
        const speedPercent = pump.getSpeedPercent();
        slider.value = speedPercent;
        output.textContent = speedPercent + '%';
      }
      
    } else if (pump.pumpType === '3-speed') {
      const speedSetting = modal.querySelector('.pump-speed-setting');
      if (speedSetting) {
        speedSetting.textContent = pump.running ? pump.getSpeedName() : '-';
      }
      
      // Highlight active speed button
      const speedBtns = modal.querySelectorAll('.pump-speed-btn');
      speedBtns.forEach((btn, index) => {
        if (index === pump.getSpeedIndex() && pump.running) {
          btn.classList.add('toggle');
          btn.setAttribute('aria-pressed', 'true');
        } else {
          btn.classList.remove('toggle');
          btn.setAttribute('aria-pressed', 'false');
        }
      });
    }
    
    // Update cavitation warning
    const cavWarning = modal.querySelector('.pump-cavitation-warning');
    if (cavWarning) {
      cavWarning.style.display = pump.cavitation.active ? 'block' : 'none';
    }
  }

  /**
   * Called when pump changes
   */
  _onPumpChange(key, pump) {
    // Update modal if open
    if (this.modals[key]?.classList.contains('open')) {
      this._updateModalUI(key);
    }
    
    // Update SVG element state
    const svgElement = document.querySelector(pump.svgElement);
    if (svgElement) {
      svgElement.setAttribute('aria-pressed', pump.running);
    }
    
    console.log(`Pump ${key} changed:`, pump.getInfo());
  }

  /**
   * Get pump by key
   */
  getPump(key) {
    return this.pumps[key];
  }

  /**
   * Get all pumps
   */
  getAllPumps() {
    return this.pumps;
  }

  /**
   * Reset all pumps
   */
  reset() {
    for (const pump of Object.values(this.pumps)) {
      pump.reset();
    }
  }

  /**
   * Destroy and cleanup
   */
  destroy() {
    for (const pump of Object.values(this.pumps)) {
      pump.destroy();
    }
    
    for (const modal of Object.values(this.modals)) {
      modal.remove();
    }
    
    this.pumps = {};
    this.modals = {};
  }
}

// Export
window.PumpManager = PumpManager;


// === js/managers/TankManager.js ===
/**
 * TankManager.js - Manages all tanks in the system
 * 
 * Creates, configures, and updates all tank components
 */

class TankManager {
  constructor(config, flowNetwork) {
    this.config = config;
    this.flowNetwork = flowNetwork;
    this.tanks = {};
    
    this._initializeTanks();
    this._setupStatusDisplay();
    
    console.log(`TankManager initialized with ${Object.keys(this.tanks).length} tanks`);
  }

  /**
   * Initialize all tanks from config
   */
  _initializeTanks() {
    for (const [key, cfg] of Object.entries(this.config)) {
      const tank = new Tank({
        ...cfg,
        flowNetwork: this.flowNetwork
      });
      
      this.tanks[key] = tank;
      this.flowNetwork.addComponent(tank);
      
      // Setup change callback
      tank.onChange = (t) => this._onTankChange(key, t);
      
      // Initial render
      tank.render();
    }
  }

  /**
   * Setup status display updates
   */
  _setupStatusDisplay() {
    // Update tank status displays every 100ms (10Hz)
    this.statusInterval = setInterval(() => {
      this._updateStatusDisplays();
    }, 100);
  }

  /**
   * Update all status displays
   */
  _updateStatusDisplays() {
    for (const [key, tank] of Object.entries(this.tanks)) {
      // Update any status elements that exist
      const statusEl = document.getElementById(`${tank.id}Status`);
      const levelEl = document.getElementById(`${tank.id}Level`);
      const volumeEl = document.getElementById(`${tank.id}Volume`);
      const flowInEl = document.getElementById(`${tank.id}FlowIn`);
      const flowOutEl = document.getElementById(`${tank.id}FlowOut`);
      
      if (statusEl) {
        statusEl.textContent = tank.isEmpty() ? '⚠️ EMPTY' : 
                               tank.isFull() ? '⚠️ FULL' : 
                               tank.isLow() ? '⚠️ LOW' : 
                               tank.isHigh() ? '⚠️ HIGH' : '✅ OK';
        
        // Color coding
        if (tank.isEmpty() || tank.isFull()) {
          statusEl.style.color = '#ff6b6b';
        } else if (tank.isLow() || tank.isHigh()) {
          statusEl.style.color = '#ffc107';
        } else {
          statusEl.style.color = '#3ddc97';
        }
      }
      
      if (levelEl) {
        levelEl.textContent = tank.getLevelPercent() + '%';
      }
      
      if (volumeEl) {
        volumeEl.textContent = tank.volume.toFixed(3) + ' m³';
      }
      
      if (flowInEl) {
        flowInEl.textContent = tank.lastInputFlow.toFixed(2) + ' m³/s';
      }
      
      if (flowOutEl) {
        flowOutEl.textContent = tank.lastOutputFlow.toFixed(2) + ' m³/s';
      }
    }
  }

  /**
   * Called when tank state changes
   */
  _onTankChange(key, tank) {
    console.log(`Tank ${key} changed:`, tank.getInfo());
  }

  /**
   * Get tank by key
   */
  getTank(key) {
    return this.tanks[key];
  }

  /**
   * Get all tanks
   */
  getAllTanks() {
    return this.tanks;
  }

  /**
   * Set tank level by key
   */
  setTankLevel(key, percent) {
    const tank = this.tanks[key];
    if (!tank) {
      console.warn(`Tank ${key} not found`);
      return;
    }
    
    tank.setLevelPercent(percent);
  }

  /**
   * Check if any tank is overflowing
   */
  hasOverflow() {
    for (const tank of Object.values(this.tanks)) {
      if (tank.isFull()) return true;
    }
    return false;
  }

  /**
   * Check if any tank is empty
   */
  hasEmpty() {
    for (const tank of Object.values(this.tanks)) {
      if (tank.isEmpty()) return true;
    }
    return false;
  }

  /**
   * Get total system volume
   */
  getTotalVolume() {
    let total = 0;
    for (const tank of Object.values(this.tanks)) {
      total += tank.volume;
    }
    return total;
  }

  /**
   * Get total system capacity
   */
  getTotalCapacity() {
    let total = 0;
    for (const tank of Object.values(this.tanks)) {
      total += tank.maxVolume;
    }
    return total;
  }

  /**
   * Get system-wide fill percentage
   */
  getSystemFillPercent() {
    const capacity = this.getTotalCapacity();
    if (capacity === 0) return 0;
    return Math.round((this.getTotalVolume() / capacity) * 100);
  }

  /**
   * Reset all tanks
   */
  reset() {
    for (const tank of Object.values(this.tanks)) {
      tank.reset();
      tank.render();
    }
    console.log('All tanks reset');
  }

  /**
   * Destroy and cleanup
   */
  destroy() {
    // Clear status interval
    if (this.statusInterval) {
      clearInterval(this.statusInterval);
    }
    
    for (const tank of Object.values(this.tanks)) {
      tank.destroy();
    }
    
    this.tanks = {};
  }
}

// Export
window.TankManager = TankManager;


// === js/managers/PressureManager.js ===
/**
 * PressureManager.js - Manages all pressure sensors
 * 
 * Creates, updates, and displays pressure readings
 */

class PressureManager {
  constructor(config, flowNetwork) {
    this.config = config;
    this.flowNetwork = flowNetwork;
    this.sensors = {};
    
    this._initializeSensors();
    this._setupStatusDisplay();
    
    console.log(`PressureManager initialized with ${Object.keys(this.sensors).length} sensors`);
  }

  /**
   * Initialize all sensors from config
   */
  _initializeSensors() {
    for (const [key, cfg] of Object.entries(this.config)) {
      const sensor = new PressureSensor({
        ...cfg,
        flowNetwork: this.flowNetwork
      });
      
      this.sensors[key] = sensor;
      this.flowNetwork.addComponent(sensor);
      
      // Setup change callback
      sensor.onChange = (s) => this._onSensorChange(key, s);
    }
  }

  /**
   * Setup status display updates
   */
  _setupStatusDisplay() {
    // Update sensor displays every 100ms (10Hz)
    this.statusInterval = setInterval(() => {
      this._updateStatusDisplays();
    }, 100);
  }

  /**
   * Update all status displays
   */
  _updateStatusDisplays() {
    for (const [key, sensor] of Object.entries(this.sensors)) {
      // Update any status elements that exist
      const pressureEl = document.getElementById(`${sensor.id}Pressure`);
      const statusEl = document.getElementById(`${sensor.id}Status`);
      const trendEl = document.getElementById(`${sensor.id}Trend`);
      
      if (pressureEl) {
        pressureEl.textContent = sensor.getPressureString();
      }
      
      if (statusEl) {
        const status = sensor.getStatus();
        statusEl.textContent = status === 'NORMAL' ? '✅ OK' : 
                               status === 'LOW' ? '⚠️ LOW' : 
                               '⚠️ HIGH';
        
        // Color coding
        if (status === 'NORMAL') {
          statusEl.style.color = '#3ddc97';
        } else {
          statusEl.style.color = '#ff6b6b';
        }
      }
      
      if (trendEl) {
        const trend = sensor.trend;
        const arrow = trend > 0.01 ? '↑' : trend < -0.01 ? '↓' : '→';
        trendEl.textContent = arrow;
        trendEl.style.color = trend > 0 ? '#3ddc97' : trend < 0 ? '#ff6b6b' : '#9bb0ff';
      }
    }
  }

  /**
   * Called when sensor reading changes
   */
  _onSensorChange(key, sensor) {
    // Optional: log significant changes
    if (Math.abs(sensor.trend) > 0.1) {
      console.log(`Pressure ${key}: ${sensor.getPressureString()} (${sensor.trend > 0 ? '↑' : '↓'})`);
    }
  }

  /**
   * Get sensor by key
   */
  getSensor(key) {
    return this.sensors[key];
  }

  /**
   * Get all sensors
   */
  getAllSensors() {
    return this.sensors;
  }

  /**
   * Get all pressure readings
   */
  getAllReadings() {
    const readings = {};
    for (const [key, sensor] of Object.entries(this.sensors)) {
      readings[key] = {
        pressure: sensor.pressure,
        units: sensor.units,
        status: sensor.getStatus(),
        alarm: sensor.alarmActive
      };
    }
    return readings;
  }

  /**
   * Check if any sensor has active alarm
   */
  hasActiveAlarms() {
    for (const sensor of Object.values(this.sensors)) {
      if (sensor.alarmActive) return true;
    }
    return false;
  }

  /**
   * Get list of active alarms
   */
  getActiveAlarms() {
    const alarms = [];
    for (const [key, sensor] of Object.entries(this.sensors)) {
      if (sensor.alarmActive) {
        alarms.push({
          sensor: key,
          name: sensor.name,
          pressure: sensor.getPressureString(),
          status: sensor.getStatus()
        });
      }
    }
    return alarms;
  }

  /**
   * Get highest pressure reading
   */
  getMaxPressure() {
    let max = 0;
    for (const sensor of Object.values(this.sensors)) {
      if (sensor.pressure > max) max = sensor.pressure;
    }
    return max;
  }

  /**
   * Get lowest pressure reading
   */
  getMinPressure() {
    let min = Infinity;
    for (const sensor of Object.values(this.sensors)) {
      if (sensor.pressure < min) min = sensor.pressure;
    }
    return min === Infinity ? 0 : min;
  }

  /**
   * Reset all sensors
   */
  reset() {
    for (const sensor of Object.values(this.sensors)) {
      sensor.reset();
    }
    console.log('All pressure sensors reset');
  }

  /**
   * Destroy and cleanup
   */
  destroy() {
    // Clear status interval
    if (this.statusInterval) {
      clearInterval(this.statusInterval);
    }
    
    for (const sensor of Object.values(this.sensors)) {
      sensor.destroy();
    }
    
    this.sensors = {};
  }
}

// Export
window.PressureManager = PressureManager;

</script>

<script>(function(){
  try{
    const dataEl = document.getElementById('design-data');
    const design = JSON.parse(dataEl.textContent);
    console.log('🎯 Loaded design:', design.metadata);

    const flowNetwork  = new (window.FlowNetwork||function(){})();
    const compManager  = new (window.ComponentManager||function(){}) (flowNetwork);
    const pipeManager  = new (window.PipeManager||function(){}) (flowNetwork);
    const valveManager = new (window.ValveManager||function(){}) (flowNetwork, compManager);
    const pumpManager  = new (window.PumpManager||function(){})  (flowNetwork, compManager);
    const tankManager  = new (window.TankManager||function(){})  (flowNetwork, compManager);
    const pressureMgr  = new (window.PressureManager||function(){}) (flowNetwork, compManager);

    compManager.loadFromDesign?.(design);
    pipeManager.loadFromDesign?.(design);

    flowNetwork.solve?.();
    valveManager.initUI?.();
    pumpManager.initUI?.();
    tankManager.initUI?.();

    let last = performance.now();
    function tick(now){
      const dt = (now - last)/1000; last = now;
      tankManager.step?.(dt);
      flowNetwork.solve?.();
      pressureMgr.updateUI?.();
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    console.log('✅ Simulator v5.3.0 running');
  }catch(e){ console.error('💥 Boot failed', e); }
})();</script>

</body>
</html>
